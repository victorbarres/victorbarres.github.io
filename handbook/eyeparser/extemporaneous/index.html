<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
01_cholitas_VC - EyeChart v2.3
</title>

<style type="text/css">
<!--
body {
	font: 100% Verdana, Arial, Helvetica, sans-serif, Tahoma;
	background: #666666;
	margin: 0;
	padding: 0;
	text-align: center;
	color: #FFFFFF;
}
.oneColLiqCtrHdr #container {
	width:auto;
	background: #FFFFFF;
	margin: 0 auto;
	text-align: left;
}
.oneColLiqCtrHdr #header {
	background: #DDDDDD; 
	padding: 0 10px 0 20px;
}
.oneColLiqCtrHdr #header h2 {
	margin: 0; 
	padding: 10px 0; 
}
.oneColLiqCtrHdr #pictureContent {
	padding: 0 20px;
	background: #FFFFFF;
}
.oneColLiqCtrHdr #mainContent {
	padding: 0 20px;
	background: #FFFFFF;
}
.oneColLiqCtrHdr #wordContent {
	padding: 0 20px;
	background: #FFFFFF;
}
-->
</style>

</head>

<body class="oneColLiqCtrHdr">

<form name="params">
	<input type="radio" name="layout" value="subject" checked="true"/> Subject Layout
	<input type="radio" name="layout" value="component"/> Component Layout
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

	<input type="checkbox" name="orient" value="stimulus"/> Stimlus-oriented
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

	<input type="radio" name="view" value="tall" checked="true"/> Tall View
	<input type="radio" name="view" value="wide"/> Wide View
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

	<input type="radio" name="thumb" value="big" checked="true"/> Big Thumbs
	<input type="radio" name="thumb" value="small"/> Small Thumbs
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

	Grid Width <input type="text" name="width" value="150" size="8"/>
	<input type="button" value="Redraw"
		onclick="resetChart();"/>
</form>

<div id="chart" style="position:relative">
</div>

<script type="text/javascript">

/* This notice must be untouched at all times.

wz_jsgraphics.js    v. 3.05
The latest version is available at
http://www.walterzorn.com
or http://www.devira.com
or http://www.walterzorn.de

Copyright (c) 2002-2009 Walter Zorn. All rights reserved.
Created 3. 11. 2002 by Walter Zorn (Web: http://www.walterzorn.com )
Last modified: 2. 2. 2009

Performance optimizations for Internet Explorer
by Thomas Frank and John Holdsworth.
fillPolygon method implemented by Matthieu Haller.

High Performance JavaScript Graphics Library.
Provides methods
- to draw lines, rectangles, ellipses, polygons
	with specifiable line thickness,
- to fill rectangles, polygons, ellipses and arcs
- to draw text.
NOTE: Operations, functions and branching have rather been optimized
to efficiency and speed than to shortness of source code.

LICENSE: LGPL

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License (LGPL) as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA,
or see http://www.gnu.org/copyleft/lesser.html
*/


var jg_ok, jg_ie, jg_fast, jg_dom, jg_moz;


function _chkDHTM(wnd, x, i)
// Under XUL, owner of 'document' must be specified explicitly
{
	x = wnd.document.body || null;
	jg_ie = x && typeof x.insertAdjacentHTML != "undefined" && wnd.document.createElement;
	jg_dom = (x && !jg_ie &&
		typeof x.appendChild != "undefined" &&
		typeof wnd.document.createRange != "undefined" &&
		typeof (i = wnd.document.createRange()).setStartBefore != "undefined" &&
		typeof i.createContextualFragment != "undefined");
	jg_fast = jg_ie && wnd.document.all && !wnd.opera;
	jg_moz = jg_dom && typeof x.style.MozOpacity != "undefined";
	jg_ok = !!(jg_ie || jg_dom);
}

function _pntCnvDom()
{
	var x = this.wnd.document.createRange();
	x.setStartBefore(this.cnv);
	x = x.createContextualFragment(jg_fast? this._htmRpc() : this.htm);
	if(this.cnv) this.cnv.appendChild(x);
	this.htm = "";
}

function _pntCnvIe()
{
	if(this.cnv) this.cnv.insertAdjacentHTML("BeforeEnd", jg_fast? this._htmRpc() : this.htm);
	this.htm = "";
}

function _pntDoc()
{
	this.wnd.document.write(jg_fast? this._htmRpc() : this.htm);
	this.htm = '';
}

function _pntN()
{
	;
}

function _mkDiv(x, y, w, h)
{
	this.htm += '<div style="position:absolute;'+
		'left:' + x + 'px;'+
		'top:' + y + 'px;'+
		'width:' + w + 'px;'+
		'height:' + h + 'px;'+
		'clip:rect(0,'+w+'px,'+h+'px,0);'+
		'background-color:' + this.color +
		(!jg_moz? ';overflow:hidden' : '')+
		';"><\/div>';
}

function _mkDivIe(x, y, w, h)
{
	this.htm += '%%'+this.color+';'+x+';'+y+';'+w+';'+h+';';
}

function _mkDivPrt(x, y, w, h)
{
	this.htm += '<div style="position:absolute;'+
		'border-left:' + w + 'px solid ' + this.color + ';'+
		'left:' + x + 'px;'+
		'top:' + y + 'px;'+
		'width:0px;'+
		'height:' + h + 'px;'+
		'clip:rect(0,'+w+'px,'+h+'px,0);'+
		'background-color:' + this.color +
		(!jg_moz? ';overflow:hidden' : '')+
		';"><\/div>';
}

var _regex =  /%%([^;]+);([^;]+);([^;]+);([^;]+);([^;]+);/g;
function _htmRpc()
{
	return this.htm.replace(
		_regex,
		'<div style="overflow:hidden;position:absolute;background-color:'+
		'$1;left:$2px;top:$3px;width:$4px;height:$5px"></div>\n');
}

function _htmPrtRpc()
{
	return this.htm.replace(
		_regex,
		'<div style="overflow:hidden;position:absolute;background-color:'+
		'$1;left:$2px;top:$3px;width:$4px;height:$5px;border-left:$4px solid $1"></div>\n');
}

function _mkLin(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1;

	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx,
		ox = x;
		while(dx > 0)
		{--dx;
			++x;
			if(p > 0)
			{
				this._mkDiv(ox, y, x-ox, 1);
				y += yIncr;
				p += pru;
				ox = x;
			}
			else p += pr;
		}
		this._mkDiv(ox, y, x2-ox+1, 1);
	}

	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy,
		oy = y;
		if(y2 <= y1)
		{
			while(dy > 0)
			{--dy;
				if(p > 0)
				{
					this._mkDiv(x++, y, 1, oy-y+1);
					y += yIncr;
					p += pru;
					oy = y;
				}
				else
				{
					y += yIncr;
					p += pr;
				}
			}
			this._mkDiv(x2, y2, 1, oy-y2+1);
		}
		else
		{
			while(dy > 0)
			{--dy;
				y += yIncr;
				if(p > 0)
				{
					this._mkDiv(x++, oy, 1, y-oy);
					p += pru;
					oy = y;
				}
				else p += pr;
			}
			this._mkDiv(x2, oy, 1, y2-oy+1);
		}
	}
}

function _mkLin2D(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1;

	var s = this.stroke;
	if(dx >= dy)
	{
		if(dx > 0 && s-3 > 0)
		{
			var _s = (s*dx*Math.sqrt(1+dy*dy/(dx*dx))-dx-(s>>1)*dy) / dx;
			_s = (!(s-4)? Math.ceil(_s) : Math.round(_s)) + 1;
		}
		else var _s = s;
		var ad = Math.ceil(s/2);

		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx,
		ox = x;
		while(dx > 0)
		{--dx;
			++x;
			if(p > 0)
			{
				this._mkDiv(ox, y, x-ox+ad, _s);
				y += yIncr;
				p += pru;
				ox = x;
			}
			else p += pr;
		}
		this._mkDiv(ox, y, x2-ox+ad+1, _s);
	}

	else
	{
		if(s-3 > 0)
		{
			var _s = (s*dy*Math.sqrt(1+dx*dx/(dy*dy))-(s>>1)*dx-dy) / dy;
			_s = (!(s-4)? Math.ceil(_s) : Math.round(_s)) + 1;
		}
		else var _s = s;
		var ad = Math.round(s/2);

		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy,
		oy = y;
		if(y2 <= y1)
		{
			++ad;
			while(dy > 0)
			{--dy;
				if(p > 0)
				{
					this._mkDiv(x++, y, _s, oy-y+ad);
					y += yIncr;
					p += pru;
					oy = y;
				}
				else
				{
					y += yIncr;
					p += pr;
				}
			}
			this._mkDiv(x2, y2, _s, oy-y2+ad);
		}
		else
		{
			while(dy > 0)
			{--dy;
				y += yIncr;
				if(p > 0)
				{
					this._mkDiv(x++, oy, _s, y-oy+ad);
					p += pru;
					oy = y;
				}
				else p += pr;
			}
			this._mkDiv(x2, oy, _s, y2-oy+ad+1);
		}
	}
}

function _mkLinDott(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1,
	drw = true;
	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx;
		while(dx > 0)
		{--dx;
			if(drw) this._mkDiv(x, y, 1, 1);
			drw = !drw;
			if(p > 0)
			{
				y += yIncr;
				p += pru;
			}
			else p += pr;
			++x;
		}
	}
	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy;
		while(dy > 0)
		{--dy;
			if(drw) this._mkDiv(x, y, 1, 1);
			drw = !drw;
			y += yIncr;
			if(p > 0)
			{
				++x;
				p += pru;
			}
			else p += pr;
		}
	}
	if(drw) this._mkDiv(x, y, 1, 1);
}

function _mkOv(left, top, width, height)
{
	var a = (++width)>>1, b = (++height)>>1,
	wod = width&1, hod = height&1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	ox = 0, oy = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1),
	w, h;
	while(y > 0)
	{
		if(st < 0)
		{
			st += bb2*((x<<1)+3);
			tt += bb4*(++x);
		}
		else if(tt < 0)
		{
			st += bb2*((x<<1)+3) - aa4*(y-1);
			tt += bb4*(++x) - aa2*(((y--)<<1)-3);
			w = x-ox;
			h = oy-y;
			if((w&2) && (h&2))
			{
				this._mkOvQds(cx, cy, x-2, y+2, 1, 1, wod, hod);
				this._mkOvQds(cx, cy, x-1, y+1, 1, 1, wod, hod);
			}
			else this._mkOvQds(cx, cy, x-1, oy, w, h, wod, hod);
			ox = x;
			oy = y;
		}
		else
		{
			tt -= aa2*((y<<1)-3);
			st -= aa4*(--y);
		}
	}
	w = a-ox+1;
	h = (oy<<1)+hod;
	y = cy-oy;
	this._mkDiv(cx-a, y, w, h);
	this._mkDiv(cx+ox+wod-1, y, w, h);
}

function _mkOv2D(left, top, width, height)
{
	var s = this.stroke;
	width += s+1;
	height += s+1;
	var a = width>>1, b = height>>1,
	wod = width&1, hod = height&1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1);

	if(s-4 < 0 && (!(s-2) || width-51 > 0 && height-51 > 0))
	{
		var ox = 0, oy = b,
		w, h,
		pxw;
		while(y > 0)
		{
			if(st < 0)
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				w = x-ox;
				h = oy-y;

				if(w-1)
				{
					pxw = w+1+(s&1);
					h = s;
				}
				else if(h-1)
				{
					pxw = s;
					h += 1+(s&1);
				}
				else pxw = h = s;
				this._mkOvQds(cx, cy, x-1, oy, pxw, h, wod, hod);
				ox = x;
				oy = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}
		}
		this._mkDiv(cx-a, cy-oy, s, (oy<<1)+hod);
		this._mkDiv(cx+a+wod-s, cy-oy, s, (oy<<1)+hod);
	}

	else
	{
		var _a = (width-(s<<1))>>1,
		_b = (height-(s<<1))>>1,
		_x = 0, _y = _b,
		_aa2 = (_a*_a)<<1, _aa4 = _aa2<<1, _bb2 = (_b*_b)<<1, _bb4 = _bb2<<1,
		_st = (_aa2>>1)*(1-(_b<<1)) + _bb2,
		_tt = (_bb2>>1) - _aa2*((_b<<1)-1),

		pxl = new Array(),
		pxt = new Array(),
		_pxb = new Array();
		pxl[0] = 0;
		pxt[0] = b;
		_pxb[0] = _b-1;
		while(y > 0)
		{
			if(st < 0)
			{
				pxl[pxl.length] = x;
				pxt[pxt.length] = y;
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				pxl[pxl.length] = x;
				st += bb2*((x<<1)+3) - aa4*(y-1);
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				pxt[pxt.length] = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}

			if(_y > 0)
			{
				if(_st < 0)
				{
					_st += _bb2*((_x<<1)+3);
					_tt += _bb4*(++_x);
					_pxb[_pxb.length] = _y-1;
				}
				else if(_tt < 0)
				{
					_st += _bb2*((_x<<1)+3) - _aa4*(_y-1);
					_tt += _bb4*(++_x) - _aa2*(((_y--)<<1)-3);
					_pxb[_pxb.length] = _y-1;
				}
				else
				{
					_tt -= _aa2*((_y<<1)-3);
					_st -= _aa4*(--_y);
					_pxb[_pxb.length-1]--;
				}
			}
		}

		var ox = -wod, oy = b,
		_oy = _pxb[0],
		l = pxl.length,
		w, h;
		for(var i = 0; i < l; i++)
		{
			if(typeof _pxb[i] != "undefined")
			{
				if(_pxb[i] < _oy || pxt[i] < oy)
				{
					x = pxl[i];
					this._mkOvQds(cx, cy, x, oy, x-ox, oy-_oy, wod, hod);
					ox = x;
					oy = pxt[i];
					_oy = _pxb[i];
				}
			}
			else
			{
				x = pxl[i];
				this._mkDiv(cx-x, cy-oy, 1, (oy<<1)+hod);
				this._mkDiv(cx+ox+wod, cy-oy, 1, (oy<<1)+hod);
				ox = x;
				oy = pxt[i];
			}
		}
		this._mkDiv(cx-a, cy-oy, 1, (oy<<1)+hod);
		this._mkDiv(cx+ox+wod, cy-oy, 1, (oy<<1)+hod);
	}
}

function _mkOvDott(left, top, width, height)
{
	var a = (++width)>>1, b = (++height)>>1,
	wod = width&1, hod = height&1, hodu = hod^1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1),
	drw = true;
	while(y > 0)
	{
		if(st < 0)
		{
			st += bb2*((x<<1)+3);
			tt += bb4*(++x);
		}
		else if(tt < 0)
		{
			st += bb2*((x<<1)+3) - aa4*(y-1);
			tt += bb4*(++x) - aa2*(((y--)<<1)-3);
		}
		else
		{
			tt -= aa2*((y<<1)-3);
			st -= aa4*(--y);
		}
		if(drw && y >= hodu) this._mkOvQds(cx, cy, x, y, 1, 1, wod, hod);
		drw = !drw;
	}
}

function _mkRect(x, y, w, h)
{
	var s = this.stroke;
	this._mkDiv(x, y, w, s);
	this._mkDiv(x+w, y, s, h);
	this._mkDiv(x, y+h, w+s, s);
	this._mkDiv(x, y+s, s, h-s);
}

function _mkRectDott(x, y, w, h)
{
	this.drawLine(x, y, x+w, y);
	this.drawLine(x+w, y, x+w, y+h);
	this.drawLine(x, y+h, x+w, y+h);
	this.drawLine(x, y, x, y+h);
}

function jsgFont()
{
	this.PLAIN = 'font-weight:normal;';
	this.BOLD = 'font-weight:bold;';
	this.ITALIC = 'font-style:italic;';
	this.ITALIC_BOLD = this.ITALIC + this.BOLD;
	this.BOLD_ITALIC = this.ITALIC_BOLD;
}
var Font = new jsgFont();

function jsgStroke()
{
	this.DOTTED = -1;
}
var Stroke = new jsgStroke();

function jsGraphics(cnv, wnd)
{
	this.setColor = function(x)
	{
		this.color = x.toLowerCase();
	};

	this.setStroke = function(x)
	{
		this.stroke = x;
		if(!(x+1))
		{
			this.drawLine = _mkLinDott;
			this._mkOv = _mkOvDott;
			this.drawRect = _mkRectDott;
		}
		else if(x-1 > 0)
		{
			this.drawLine = _mkLin2D;
			this._mkOv = _mkOv2D;
			this.drawRect = _mkRect;
		}
		else
		{
			this.drawLine = _mkLin;
			this._mkOv = _mkOv;
			this.drawRect = _mkRect;
		}
	};

	this.setPrintable = function(arg)
	{
		this.printable = arg;
		if(jg_fast)
		{
			this._mkDiv = _mkDivIe;
			this._htmRpc = arg? _htmPrtRpc : _htmRpc;
		}
		else this._mkDiv = arg? _mkDivPrt : _mkDiv;
	};

	this.setFont = function(fam, sz, sty)
	{
		this.ftFam = fam;
		this.ftSz = sz;
		this.ftSty = sty || Font.PLAIN;
	};

	this.drawPolyline = this.drawPolyLine = function(x, y)
	{
		for (var i=x.length - 1; i;)
		{--i;
			this.drawLine(x[i], y[i], x[i+1], y[i+1]);
		}
	};

	this.fillRect = function(x, y, w, h)
	{
		this._mkDiv(x, y, w, h);
	};

	this.drawPolygon = function(x, y)
	{
		this.drawPolyline(x, y);
		this.drawLine(x[x.length-1], y[x.length-1], x[0], y[0]);
	};

	this.drawEllipse = this.drawOval = function(x, y, w, h)
	{
		this._mkOv(x, y, w, h);
	};

	this.fillEllipse = this.fillOval = function(left, top, w, h)
	{
		var a = w>>1, b = h>>1,
		wod = w&1, hod = h&1,
		cx = left+a, cy = top+b,
		x = 0, y = b, oy = b,
		aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
		st = (aa2>>1)*(1-(b<<1)) + bb2,
		tt = (bb2>>1) - aa2*((b<<1)-1),
		xl, dw, dh;
		if(w) while(y > 0)
		{
			if(st < 0)
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				xl = cx-x;
				dw = (x<<1)+wod;
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				dh = oy-y;
				this._mkDiv(xl, cy-oy, dw, dh);
				this._mkDiv(xl, cy+y+hod, dw, dh);
				oy = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}
		}
		this._mkDiv(cx-a, cy-oy, w, (oy<<1)+hod);
	};

	this.fillArc = function(iL, iT, iW, iH, fAngA, fAngZ)
	{
		var a = iW>>1, b = iH>>1,
		iOdds = (iW&1) | ((iH&1) << 16),
		cx = iL+a, cy = iT+b,
		x = 0, y = b, ox = x, oy = y,
		aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
		st = (aa2>>1)*(1-(b<<1)) + bb2,
		tt = (bb2>>1) - aa2*((b<<1)-1),
		// Vars for radial boundary lines
		xEndA, yEndA, xEndZ, yEndZ,
		iSects = (1 << (Math.floor((fAngA %= 360.0)/180.0) << 3))
				| (2 << (Math.floor((fAngZ %= 360.0)/180.0) << 3))
				| ((fAngA >= fAngZ) << 16),
		aBndA = new Array(b+1), aBndZ = new Array(b+1);
		
		// Set up radial boundary lines
		fAngA *= Math.PI/180.0;
		fAngZ *= Math.PI/180.0;
		xEndA = cx+Math.round(a*Math.cos(fAngA));
		yEndA = cy+Math.round(-b*Math.sin(fAngA));
		_mkLinVirt(aBndA, cx, cy, xEndA, yEndA);
		xEndZ = cx+Math.round(a*Math.cos(fAngZ));
		yEndZ = cy+Math.round(-b*Math.sin(fAngZ));
		_mkLinVirt(aBndZ, cx, cy, xEndZ, yEndZ);

		while(y > 0)
		{
			if(st < 0) // Advance x
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0) // Advance x and y
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				ox = x;
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				this._mkArcDiv(ox, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
				oy = y;
			}
			else // Advance y
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
				if(y && (aBndA[y] != aBndA[y-1] || aBndZ[y] != aBndZ[y-1]))
				{
					this._mkArcDiv(x, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
					ox = x;
					oy = y;
				}
			}
		}
		this._mkArcDiv(x, 0, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
		if(iOdds >> 16) // Odd height
		{
			if(iSects >> 16) // Start-angle > end-angle
			{
				var xl = (yEndA <= cy || yEndZ > cy)? (cx - x) : cx;
				this._mkDiv(xl, cy, x + cx - xl + (iOdds & 0xffff), 1);
			}
			else if((iSects & 0x01) && yEndZ > cy)
				this._mkDiv(cx - x, cy, x, 1);
		}
	};

/* fillPolygon method, implemented by Matthieu Haller.
This javascript function is an adaptation of the gdImageFilledPolygon for Walter Zorn lib.
C source of GD 1.8.4 found at http://www.boutell.com/gd/

THANKS to Kirsten Schulz for the polygon fixes!

The intersection finding technique of this code could be improved
by remembering the previous intertersection, and by using the slope.
That could help to adjust intersections to produce a nice
interior_extrema. */
	this.fillPolygon = function(array_x, array_y)
	{
		var i;
		var y;
		var miny, maxy;
		var x1, y1;
		var x2, y2;
		var ind1, ind2;
		var ints;

		var n = array_x.length;
		if(!n) return;

		miny = array_y[0];
		maxy = array_y[0];
		for(i = 1; i < n; i++)
		{
			if(array_y[i] < miny)
				miny = array_y[i];

			if(array_y[i] > maxy)
				maxy = array_y[i];
		}
		for(y = miny; y <= maxy; y++)
		{
			var polyInts = new Array();
			ints = 0;
			for(i = 0; i < n; i++)
			{
				if(!i)
				{
					ind1 = n-1;
					ind2 = 0;
				}
				else
				{
					ind1 = i-1;
					ind2 = i;
				}
				y1 = array_y[ind1];
				y2 = array_y[ind2];
				if(y1 < y2)
				{
					x1 = array_x[ind1];
					x2 = array_x[ind2];
				}
				else if(y1 > y2)
				{
					y2 = array_y[ind1];
					y1 = array_y[ind2];
					x2 = array_x[ind1];
					x1 = array_x[ind2];
				}
				else continue;

				 //  Modified 11. 2. 2004 Walter Zorn
				if((y >= y1) && (y < y2))
					polyInts[ints++] = Math.round((y-y1) * (x2-x1) / (y2-y1) + x1);

				else if((y == maxy) && (y > y1) && (y <= y2))
					polyInts[ints++] = Math.round((y-y1) * (x2-x1) / (y2-y1) + x1);
			}
			polyInts.sort(_CompInt);
			for(i = 0; i < ints; i+=2)
				this._mkDiv(polyInts[i], y, polyInts[i+1]-polyInts[i]+1, 1);
		}
	};

	this.drawString = function(txt, x, y)
	{
		this.htm += '<div style="position:absolute;white-space:nowrap;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			'font-family:' +  this.ftFam + ';'+
			'font-size:' + this.ftSz + ';'+
			'color:' + this.color + ';' + this.ftSty + '">'+
			txt +
			'<\/div>';
	};
	
	this.stringWidth = function(txt)
	{
		var htm = '<div id="string_ruler" style="visibility:hidden;position:absolute;white-space:nowrap;'+
			'font-family:' +  this.ftFam + ';'+
			'font-size:' + this.ftSz + ';'+
			'color:' + this.color + ';' + this.ftSty + '">'+
			txt +
			'<\/div>';

		var org_htm = this.cnv.innerHTML;
		this.cnv.innerHTML = htm;
		var width = this.wnd.document.getElementById('string_ruler').offsetWidth;
		this.cnv.innerHTML = org_htm;
		return width;
	}

/* drawStringRect() added by Rick Blommers.
Allows to specify the size of the text rectangle and to align the
text both horizontally (e.g. right) and vertically within that rectangle */
	this.drawStringRect = function(txt, x, y, width, halign, a)
	{
		this.htm += '<div style="position:absolute;overflow:hidden;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			'width:'+width +'px;'+
			'text-align:'+halign+';'+
			'font-family:' +  this.ftFam + ';'+
			'font-size:' + this.ftSz + ';'+
			'color:' + this.color + ';' + this.ftSty + '"' +
			(a? (' '+a) : '') + '>'+
			txt +
			'<\/div>';
	};

	this.drawImage = function(imgSrc, x, y, w, h, a)
	{
		this.htm += '<div style="position:absolute;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			// w (width) and h (height) arguments are now optional.
			// Added by Mahmut Keygubatli, 14.1.2008
			(w? ('width:' +  w + 'px;') : '') +
			(h? ('height:' + h + 'px;'):'')+'">'+
			'<img src="' + imgSrc +'"'+ (w ? (' width="' + w + '"'):'')+ (h ? (' height="' + h + '"'):'') + (a? (' '+a) : '') + '>'+
			'<\/div>';
	};

	this.clear = function()
	{
		this.htm = "";
		if(this.cnv) this.cnv.innerHTML = "";
	};

	this._mkOvQds = function(cx, cy, x, y, w, h, wod, hod)
	{
		var xl = cx - x, xr = cx + x + wod - w, yt = cy - y, yb = cy + y + hod - h;
		if(xr > xl+w)
		{
			this._mkDiv(xr, yt, w, h);
			this._mkDiv(xr, yb, w, h);
		}
		else
			w = xr - xl + w;
		this._mkDiv(xl, yt, w, h);
		this._mkDiv(xl, yb, w, h);
	};
	
	this._mkArcDiv = function(x, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects)
	{
		var xrDef = cx + x + (iOdds & 0xffff), y2, h = oy - y, xl, xr, w;

		if(!h) h = 1;
		x = cx - x;

		if(iSects & 0xff0000) // Start-angle > end-angle
		{
			y2 = cy - y - h;
			if(iSects & 0x00ff)
			{
				if(iSects & 0x02)
				{
					xl = Math.max(x, aBndZ[y]);
					w = xrDef - xl;
					if(w > 0) this._mkDiv(xl, y2, w, h);
				}
				if(iSects & 0x01)
				{
					xr = Math.min(xrDef, aBndA[y]);
					w = xr - x;
					if(w > 0) this._mkDiv(x, y2, w, h);
				}
			}
			else
				this._mkDiv(x, y2, xrDef - x, h);
			y2 = cy + y + (iOdds >> 16);
			if(iSects & 0xff00)
			{
				if(iSects & 0x0100)
				{
					xl = Math.max(x, aBndA[y]);
					w = xrDef - xl;
					if(w > 0) this._mkDiv(xl, y2, w, h);
				}
				if(iSects & 0x0200)
				{
					xr = Math.min(xrDef, aBndZ[y]);
					w = xr - x;
					if(w > 0) this._mkDiv(x, y2, w, h);
				}
			}
			else
				this._mkDiv(x, y2, xrDef - x, h);
		}
		else
		{
			if(iSects & 0x00ff)
			{
				if(iSects & 0x02)
					xl = Math.max(x, aBndZ[y]);
				else
					xl = x;
				if(iSects & 0x01)
					xr = Math.min(xrDef, aBndA[y]);
				else
					xr = xrDef;
				y2 = cy - y - h;
				w = xr - xl;
				if(w > 0) this._mkDiv(xl, y2, w, h);
			}
			if(iSects & 0xff00)
			{
				if(iSects & 0x0100)
					xl = Math.max(x, aBndA[y]);
				else
					xl = x;
				if(iSects & 0x0200)
					xr = Math.min(xrDef, aBndZ[y]);
				else
					xr = xrDef;
				y2 = cy + y + (iOdds >> 16);
				w = xr - xl;
				if(w > 0) this._mkDiv(xl, y2, w, h);
			}
		}
	};

	this.setStroke(1);
	this.setFont("verdana,geneva,helvetica,sans-serif", "12px", Font.PLAIN);
	this.color = "#000000";
	this.htm = "";
	this.wnd = wnd || window;

	if(!jg_ok) _chkDHTM(this.wnd);
	if(jg_ok)
	{
		if(cnv)
		{
			if(typeof(cnv) == "string")
				this.cont = document.all? (this.wnd.document.all[cnv] || null)
					: document.getElementById? (this.wnd.document.getElementById(cnv) || null)
					: null;
			else if(cnv == window.document)
				this.cont = document.getElementsByTagName("body")[0];
			// If cnv is a direct reference to a canvas DOM node
			// (option suggested by Andreas Luleich)
			else this.cont = cnv;
			// Create new canvas inside container DIV. Thus the drawing and clearing
			// methods won't interfere with the container's inner html.
			// Solution suggested by Vladimir.
			this.cnv = this.wnd.document.createElement("div");
			this.cnv.style.fontSize=0;
			this.cont.appendChild(this.cnv);
			this.paint = jg_dom? _pntCnvDom : _pntCnvIe;
		}
		else
			this.paint = _pntDoc;
	}
	else
		this.paint = _pntN;

	this.setPrintable(false);
}

function _mkLinVirt(aLin, x1, y1, x2, y2)
{
	var dx = Math.abs(x2-x1), dy = Math.abs(y2-y1),
	x = x1, y = y1,
	xIncr = (x1 > x2)? -1 : 1,
	yIncr = (y1 > y2)? -1 : 1,
	p,
	i = 0;
	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1);
		p = pr-dx;
		while(dx > 0)
		{--dx;
			if(p > 0)    //  Increment y
			{
				aLin[i++] = x;
				y += yIncr;
				p += pru;
			}
			else p += pr;
			x += xIncr;
		}
	}
	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1);
		p = pr-dy;
		while(dy > 0)
		{--dy;
			y += yIncr;
			aLin[i++] = x;
			if(p > 0)    //  Increment x
			{
				x += xIncr;
				p += pru;
			}
			else p += pr;
		}
	}
	for(var len = aLin.length, i = len-i; i;)
		aLin[len-(i--)] = x;
};

function _CompInt(x, y)
{
	return(x - y);
}



</script>



<script type="text/javascript">

/* This notice must be untouched at all times.
Copyright (c) 2002-2008 Walter Zorn. All rights reserved.

wz_tooltip.js	 v. 5.31

The latest version is available at
http://www.walterzorn.com
or http://www.devira.com
or http://www.walterzorn.de

Created 1.12.2002 by Walter Zorn (Web: http://www.walterzorn.com )
Last modified: 7.11.2008

Easy-to-use cross-browser tooltips.
Just include the script at the beginning of the <body> section, and invoke
Tip('Tooltip text') to show and UnTip() to hide the tooltip, from the desired
HTML eventhandlers. Example:
<a onmouseover="Tip('Some text')" onmouseout="UnTip()" href="index.htm">My home page</a>
No container DIV required.
By default, width and height of tooltips are automatically adapted to content.
Is even capable of dynamically converting arbitrary HTML elements to tooltips
by calling TagToTip('ID_of_HTML_element_to_be_converted') instead of Tip(),
which means you can put important, search-engine-relevant stuff into tooltips.
Appearance & behaviour of tooltips can be individually configured
via commands passed to Tip() or TagToTip().

Tab Width: 4
LICENSE: LGPL

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License (LGPL) as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

For more details on the GNU Lesser General Public License,
see http://www.gnu.org/copyleft/lesser.html
*/

var config = new Object();


//===================  GLOBAL TOOLTIP CONFIGURATION  =========================//
var tt_Debug	= true		// false or true - recommended: false once you release your page to the public
var tt_Enabled	= true		// Allows to (temporarily) suppress tooltips, e.g. by providing the user with a button that sets this global variable to false
var TagsToTip	= true		// false or true - if true, HTML elements to be converted to tooltips via TagToTip() are automatically hidden;
							// if false, you should hide those HTML elements yourself

// For each of the following config variables there exists a command, which is
// just the variablename in uppercase, to be passed to Tip() or TagToTip() to
// configure tooltips individually. Individual commands override global
// configuration. Order of commands is arbitrary.
// Example: onmouseover="Tip('Tooltip text', LEFT, true, BGCOLOR, '#FF9900', FADEIN, 400)"

config. Above			= false		// false or true - tooltip above mousepointer
config. BgColor			= '#E2E7FF'	// Background colour (HTML colour value, in quotes)
config. BgImg			= ''		// Path to background image, none if empty string ''
config. BorderColor		= '#003099'
config. BorderStyle		= 'solid'	// Any permitted CSS value, but I recommend 'solid', 'dotted' or 'dashed'
config. BorderWidth		= 1
config. CenterMouse		= false		// false or true - center the tip horizontally below (or above) the mousepointer
config. ClickClose		= false		// false or true - close tooltip if the user clicks somewhere
config. ClickSticky		= false		// false or true - make tooltip sticky if user left-clicks on the hovered element while the tooltip is active
config. CloseBtn		= false		// false or true - closebutton in titlebar
config. CloseBtnColors	= ['#990000', '#FFFFFF', '#DD3333', '#FFFFFF']	// [Background, text, hovered background, hovered text] - use empty strings '' to inherit title colours
config. CloseBtnText	= '&nbsp;X&nbsp;'	// Close button text (may also be an image tag)
config. CopyContent		= true		// When converting a HTML element to a tooltip, copy only the element's content, rather than converting the element by its own
config. Delay			= 400		// Time span in ms until tooltip shows up
config. Duration		= 0			// Time span in ms after which the tooltip disappears; 0 for infinite duration, < 0 for delay in ms _after_ the onmouseout until the tooltip disappears
config. Exclusive		= false		// false or true - no other tooltip can appear until the current one has actively been closed
config. FadeIn			= 100		// Fade-in duration in ms, e.g. 400; 0 for no animation
config. FadeOut			= 100
config. FadeInterval	= 30		// Duration of each fade step in ms (recommended: 30) - shorter is smoother but causes more CPU-load
config. Fix				= null		// Fixated position, two modes. Mode 1: x- an y-coordinates in brackets, e.g. [210, 480]. Mode 2: Show tooltip at a position related to an HTML element: [ID of HTML element, x-offset, y-offset from HTML element], e.g. ['SomeID', 10, 30]. Value null (default) for no fixated positioning.
config. FollowMouse		= true		// false or true - tooltip follows the mouse
config. FontColor		= '#000044'
config. FontFace		= 'Verdana,Geneva,sans-serif'
config. FontSize		= '8pt'		// E.g. '9pt' or '12px' - unit is mandatory
config. FontWeight		= 'normal'	// 'normal' or 'bold';
config. Height			= 0			// Tooltip height; 0 for automatic adaption to tooltip content, < 0 (e.g. -100) for a maximum for automatic adaption
config. JumpHorz		= false		// false or true - jump horizontally to other side of mouse if tooltip would extend past clientarea boundary
config. JumpVert		= true		// false or true - jump vertically		"
config. Left			= false		// false or true - tooltip on the left of the mouse
config. OffsetX			= 14		// Horizontal offset of left-top corner from mousepointer
config. OffsetY			= 8			// Vertical offset
config. Opacity			= 100		// Integer between 0 and 100 - opacity of tooltip in percent
config. Padding			= 3			// Spacing between border and content
config. Shadow			= false		// false or true
config. ShadowColor		= '#C0C0C0'
config. ShadowWidth		= 5
config. Sticky			= false		// false or true - fixate tip, ie. don't follow the mouse and don't hide on mouseout
config. TextAlign		= 'left'	// 'left', 'right' or 'justify'
config. Title			= ''		// Default title text applied to all tips (no default title: empty string '')
config. TitleAlign		= 'left'	// 'left' or 'right' - text alignment inside the title bar
config. TitleBgColor	= ''		// If empty string '', BorderColor will be used
config. TitleFontColor	= '#FFFFFF'	// Color of title text - if '', BgColor (of tooltip body) will be used
config. TitleFontFace	= ''		// If '' use FontFace (boldified)
config. TitleFontSize	= ''		// If '' use FontSize
config. TitlePadding	= 2
config. Width			= 0			// Tooltip width; 0 for automatic adaption to tooltip content; < -1 (e.g. -240) for a maximum width for that automatic adaption;
									// -1: tooltip width confined to the width required for the titlebar
//=======  END OF TOOLTIP CONFIG, DO NOT CHANGE ANYTHING BELOW  ==============//




//=====================  PUBLIC  =============================================//
function Tip()
{
	tt_Tip(arguments, null);
}
function TagToTip()
{
	var t2t = tt_GetElt(arguments[0]);
	if(t2t)
		tt_Tip(arguments, t2t);
}
function UnTip()
{
	tt_OpReHref();
	if(tt_aV[DURATION] < 0 && (tt_iState & 0x2))
		tt_tDurt.Timer("tt_HideInit()", -tt_aV[DURATION], true);
	else if(!(tt_aV[STICKY] && (tt_iState & 0x2)))
		tt_HideInit();
}

//==================  PUBLIC PLUGIN API	 =====================================//
// Extension eventhandlers currently supported:
// OnLoadConfig, OnCreateContentString, OnSubDivsCreated, OnShow, OnMoveBefore,
// OnMoveAfter, OnHideInit, OnHide, OnKill

var tt_aElt = new Array(10), // Container DIV, outer title & body DIVs, inner title & body TDs, closebutton SPAN, shadow DIVs, and IFRAME to cover windowed elements in IE
tt_aV = new Array(),	// Caches and enumerates config data for currently active tooltip
tt_sContent,			// Inner tooltip text or HTML
tt_t2t, tt_t2tDad,		// Tag converted to tip, and its DOM parent element
tt_musX, tt_musY,
tt_over,
tt_x, tt_y, tt_w, tt_h; // Position, width and height of currently displayed tooltip

function tt_Extension()
{
	tt_ExtCmdEnum();
	tt_aExt[tt_aExt.length] = this;
	return this;
}
function tt_SetTipPos(x, y)
{
	var css = tt_aElt[0].style;

	tt_x = x;
	tt_y = y;
	css.left = x + "px";
	css.top = y + "px";
	if(tt_ie56)
	{
		var ifrm = tt_aElt[tt_aElt.length - 1];
		if(ifrm)
		{
			ifrm.style.left = css.left;
			ifrm.style.top = css.top;
		}
	}
}
function tt_HideInit()
{
	if(tt_iState)
	{
		tt_ExtCallFncs(0, "HideInit");
		tt_iState &= ~(0x4 | 0x8);
		if(tt_flagOpa && tt_aV[FADEOUT])
		{
			tt_tFade.EndTimer();
			if(tt_opa)
			{
				var n = Math.round(tt_aV[FADEOUT] / (tt_aV[FADEINTERVAL] * (tt_aV[OPACITY] / tt_opa)));
				tt_Fade(tt_opa, tt_opa, 0, n);
				return;
			}
		}
		tt_tHide.Timer("tt_Hide();", 1, false);
	}
}
function tt_Hide()
{
	if(tt_db && tt_iState)
	{
		tt_OpReHref();
		if(tt_iState & 0x2)
		{
			tt_aElt[0].style.visibility = "hidden";
			tt_ExtCallFncs(0, "Hide");
		}
		tt_tShow.EndTimer();
		tt_tHide.EndTimer();
		tt_tDurt.EndTimer();
		tt_tFade.EndTimer();
		if(!tt_op && !tt_ie)
		{
			tt_tWaitMov.EndTimer();
			tt_bWait = false;
		}
		if(tt_aV[CLICKCLOSE] || tt_aV[CLICKSTICKY])
			tt_RemEvtFnc(document, "mouseup", tt_OnLClick);
		tt_ExtCallFncs(0, "Kill");
		// In case of a TagToTip tip, hide converted DOM node and
		// re-insert it into DOM
		if(tt_t2t && !tt_aV[COPYCONTENT])
			tt_UnEl2Tip();
		tt_iState = 0;
		tt_over = null;
		tt_ResetMainDiv();
		if(tt_aElt[tt_aElt.length - 1])
			tt_aElt[tt_aElt.length - 1].style.display = "none";
	}
}
function tt_GetElt(id)
{
	return(document.getElementById ? document.getElementById(id)
			: document.all ? document.all[id]
			: null);
}
function tt_GetDivW(el)
{
	return(el ? (el.offsetWidth || el.style.pixelWidth || 0) : 0);
}
function tt_GetDivH(el)
{
	return(el ? (el.offsetHeight || el.style.pixelHeight || 0) : 0);
}
function tt_GetScrollX()
{
	return(window.pageXOffset || (tt_db ? (tt_db.scrollLeft || 0) : 0));
}
function tt_GetScrollY()
{
	return(window.pageYOffset || (tt_db ? (tt_db.scrollTop || 0) : 0));
}
function tt_GetClientW()
{
	return tt_GetWndCliSiz("Width");
}
function tt_GetClientH()
{
	return tt_GetWndCliSiz("Height");
}
function tt_GetEvtX(e)
{
	return (e ? ((typeof(e.pageX) != tt_u) ? e.pageX : (e.clientX + tt_GetScrollX())) : 0);
}
function tt_GetEvtY(e)
{
	return (e ? ((typeof(e.pageY) != tt_u) ? e.pageY : (e.clientY + tt_GetScrollY())) : 0);
}
function tt_AddEvtFnc(el, sEvt, PFnc)
{
	if(el)
	{
		if(el.addEventListener)
			el.addEventListener(sEvt, PFnc, false);
		else
			el.attachEvent("on" + sEvt, PFnc);
	}
}
function tt_RemEvtFnc(el, sEvt, PFnc)
{
	if(el)
	{
		if(el.removeEventListener)
			el.removeEventListener(sEvt, PFnc, false);
		else
			el.detachEvent("on" + sEvt, PFnc);
	}
}
function tt_GetDad(el)
{
	return(el.parentNode || el.parentElement || el.offsetParent);
}
function tt_MovDomNode(el, dadFrom, dadTo)
{
	if(dadFrom)
		dadFrom.removeChild(el);
	if(dadTo)
		dadTo.appendChild(el);
}

//======================  PRIVATE  ===========================================//
var tt_aExt = new Array(),	// Array of extension objects

tt_db, tt_op, tt_ie, tt_ie56, tt_bBoxOld,	// Browser flags
tt_body,
tt_ovr_,				// HTML element the mouse is currently over
tt_flagOpa,				// Opacity support: 1=IE, 2=Khtml, 3=KHTML, 4=Moz, 5=W3C
tt_maxPosX, tt_maxPosY,
tt_iState = 0,			// Tooltip active |= 1, shown |= 2, move with mouse |= 4, exclusive |= 8
tt_opa,					// Currently applied opacity
tt_bJmpVert, tt_bJmpHorz,// Tip temporarily on other side of mouse
tt_elDeHref,			// The tag from which we've removed the href attribute
// Timer
tt_tShow = new Number(0), tt_tHide = new Number(0), tt_tDurt = new Number(0),
tt_tFade = new Number(0), tt_tWaitMov = new Number(0),
tt_bWait = false,
tt_u = "undefined";


function tt_Init()
{
	tt_MkCmdEnum();
	// Send old browsers instantly to hell
	if(!tt_Browser() || !tt_MkMainDiv())
		return;
	tt_IsW3cBox();
	tt_OpaSupport();
	tt_AddEvtFnc(document, "mousemove", tt_Move);
	// In Debug mode we search for TagToTip() calls in order to notify
	// the user if they've forgotten to set the TagsToTip config flag
	if(TagsToTip || tt_Debug)
		tt_SetOnloadFnc();
	// Ensure the tip be hidden when the page unloads
	tt_AddEvtFnc(window, "unload", tt_Hide);
}
// Creates command names by translating config variable names to upper case
function tt_MkCmdEnum()
{
	var n = 0;
	for(var i in config)
		eval("window." + i.toString().toUpperCase() + " = " + n++);
	tt_aV.length = n;
}
function tt_Browser()
{
	var n, nv, n6, w3c;

	n = navigator.userAgent.toLowerCase(),
	nv = navigator.appVersion;
	tt_op = (document.defaultView && typeof(eval("w" + "indow" + "." + "o" + "p" + "er" + "a")) != tt_u);
	tt_ie = n.indexOf("msie") != -1 && document.all && !tt_op;
	if(tt_ie)
	{
		var ieOld = (!document.compatMode || document.compatMode == "BackCompat");
		tt_db = !ieOld ? document.documentElement : (document.body || null);
		if(tt_db)
			tt_ie56 = parseFloat(nv.substring(nv.indexOf("MSIE") + 5)) >= 5.5
					&& typeof document.body.style.maxHeight == tt_u;
	}
	else
	{
		tt_db = document.documentElement || document.body ||
				(document.getElementsByTagName ? document.getElementsByTagName("body")[0]
				: null);
		if(!tt_op)
		{
			n6 = document.defaultView && typeof document.defaultView.getComputedStyle != tt_u;
			w3c = !n6 && document.getElementById;
		}
	}
	tt_body = (document.getElementsByTagName ? document.getElementsByTagName("body")[0]
				: (document.body || null));
	if(tt_ie || n6 || tt_op || w3c)
	{
		if(tt_body && tt_db)
		{
			if(document.attachEvent || document.addEventListener)
				return true;
		}
		else
			tt_Err("wz_tooltip.js must be included INSIDE the body section,"
					+ " immediately after the opening <body> tag.", false);
	}
	tt_db = null;
	return false;
}
function tt_MkMainDiv()
{
	// Create the tooltip DIV
	if(tt_body.insertAdjacentHTML)
		tt_body.insertAdjacentHTML("afterBegin", tt_MkMainDivHtm());
	else if(typeof tt_body.innerHTML != tt_u && document.createElement && tt_body.appendChild)
		tt_body.appendChild(tt_MkMainDivDom());
	if(window.tt_GetMainDivRefs /* FireFox Alzheimer */ && tt_GetMainDivRefs())
		return true;
	tt_db = null;
	return false;
}
function tt_MkMainDivHtm()
{
	return(
		'<div id="WzTtDiV"></div>' +
		(tt_ie56 ? ('<iframe id="WzTtIfRm" src="javascript:false" scrolling="no" frameborder="0" style="filter:Alpha(opacity=0);position:absolute;top:0px;left:0px;display:none;"></iframe>')
		: '')
	);
}
function tt_MkMainDivDom()
{
	var el = document.createElement("div");
	if(el)
		el.id = "WzTtDiV";
	return el;
}
function tt_GetMainDivRefs()
{
	tt_aElt[0] = tt_GetElt("WzTtDiV");
	if(tt_ie56 && tt_aElt[0])
	{
		tt_aElt[tt_aElt.length - 1] = tt_GetElt("WzTtIfRm");
		if(!tt_aElt[tt_aElt.length - 1])
			tt_aElt[0] = null;
	}
	if(tt_aElt[0])
	{
		var css = tt_aElt[0].style;

		css.visibility = "hidden";
		css.position = "absolute";
		css.overflow = "hidden";
		return true;
	}
	return false;
}
function tt_ResetMainDiv()
{
	tt_SetTipPos(0, 0);
	tt_aElt[0].innerHTML = "";
	tt_aElt[0].style.width = "0px";
	tt_h = 0;
}
function tt_IsW3cBox()
{
	var css = tt_aElt[0].style;

	css.padding = "10px";
	css.width = "40px";
	tt_bBoxOld = (tt_GetDivW(tt_aElt[0]) == 40);
	css.padding = "0px";
	tt_ResetMainDiv();
}
function tt_OpaSupport()
{
	var css = tt_body.style;

	tt_flagOpa = (typeof(css.KhtmlOpacity) != tt_u) ? 2
				: (typeof(css.KHTMLOpacity) != tt_u) ? 3
				: (typeof(css.MozOpacity) != tt_u) ? 4
				: (typeof(css.opacity) != tt_u) ? 5
				: (typeof(css.filter) != tt_u) ? 1
				: 0;
}
// Ported from http://dean.edwards.name/weblog/2006/06/again/
// (Dean Edwards et al.)
function tt_SetOnloadFnc()
{
	tt_AddEvtFnc(document, "DOMContentLoaded", tt_HideSrcTags);
	tt_AddEvtFnc(window, "load", tt_HideSrcTags);
	if(tt_body.attachEvent)
		tt_body.attachEvent("onreadystatechange",
			function() {
				if(tt_body.readyState == "complete")
					tt_HideSrcTags();
			} );
	if(/WebKit|KHTML/i.test(navigator.userAgent))
	{
		var t = setInterval(function() {
					if(/loaded|complete/.test(document.readyState))
					{
						clearInterval(t);
						tt_HideSrcTags();
					}
				}, 10);
	}
}
function tt_HideSrcTags()
{
	if(!window.tt_HideSrcTags || window.tt_HideSrcTags.done)
		return;
	window.tt_HideSrcTags.done = true;
	if(!tt_HideSrcTagsRecurs(tt_body))
		tt_Err("There are HTML elements to be converted to tooltips.\nIf you"
				+ " want these HTML elements to be automatically hidden, you"
				+ " must edit wz_tooltip.js, and set TagsToTip in the global"
				+ " tooltip configuration to true.", true);
}
function tt_HideSrcTagsRecurs(dad)
{
	var ovr, asT2t;
	// Walk the DOM tree for tags that have an onmouseover or onclick attribute
	// containing a TagToTip('...') call.
	// (.childNodes first since .children is bugous in Safari)
	var a = dad.childNodes || dad.children || null;

	for(var i = a ? a.length : 0; i;)
	{--i;
		if(!tt_HideSrcTagsRecurs(a[i]))
			return false;
		ovr = a[i].getAttribute ? (a[i].getAttribute("onmouseover") || a[i].getAttribute("onclick"))
				: (typeof a[i].onmouseover == "function") ? (a[i].onmouseover || a[i].onclick)
				: null;
		if(ovr)
		{
			asT2t = ovr.toString().match(/TagToTip\s*\(\s*'[^'.]+'\s*[\),]/);
			if(asT2t && asT2t.length)
			{
				if(!tt_HideSrcTag(asT2t[0]))
					return false;
			}
		}
	}
	return true;
}
function tt_HideSrcTag(sT2t)
{
	var id, el;

	// The ID passed to the found TagToTip() call identifies an HTML element
	// to be converted to a tooltip, so hide that element
	id = sT2t.replace(/.+'([^'.]+)'.+/, "$1");
	el = tt_GetElt(id);
	if(el)
	{
		if(tt_Debug && !TagsToTip)
			return false;
		else
			el.style.display = "none";
	}
	else
		tt_Err("Invalid ID\n'" + id + "'\npassed to TagToTip()."
				+ " There exists no HTML element with that ID.", true);
	return true;
}
function tt_Tip(arg, t2t)
{
	if(!tt_db || (tt_iState & 0x8))
		return;
	if(tt_iState)
		tt_Hide();
	if(!tt_Enabled)
		return;
	tt_t2t = t2t;
	if(!tt_ReadCmds(arg))
		return;
	tt_iState = 0x1 | 0x4;
	tt_AdaptConfig1();
	tt_MkTipContent(arg);
	tt_MkTipSubDivs();
	tt_FormatTip();
	tt_bJmpVert = false;
	tt_bJmpHorz = false;
	tt_maxPosX = tt_GetClientW() + tt_GetScrollX() - tt_w - 1;
	tt_maxPosY = tt_GetClientH() + tt_GetScrollY() - tt_h - 1;
	tt_AdaptConfig2();
	// Ensure the tip be shown and positioned before the first onmousemove
	tt_OverInit();
	tt_ShowInit();
	tt_Move();
}
function tt_ReadCmds(a)
{
	var i;

	// First load the global config values, to initialize also values
	// for which no command is passed
	i = 0;
	for(var j in config)
		tt_aV[i++] = config[j];
	// Then replace each cached config value for which a command is
	// passed (ensure the # of command args plus value args be even)
	if(a.length & 1)
	{
		for(i = a.length - 1; i > 0; i -= 2)
			tt_aV[a[i - 1]] = a[i];
		return true;
	}
	tt_Err("Incorrect call of Tip() or TagToTip().\n"
			+ "Each command must be followed by a value.", true);
	return false;
}
function tt_AdaptConfig1()
{
	tt_ExtCallFncs(0, "LoadConfig");
	// Inherit unspecified title formattings from body
	if(!tt_aV[TITLEBGCOLOR].length)
		tt_aV[TITLEBGCOLOR] = tt_aV[BORDERCOLOR];
	if(!tt_aV[TITLEFONTCOLOR].length)
		tt_aV[TITLEFONTCOLOR] = tt_aV[BGCOLOR];
	if(!tt_aV[TITLEFONTFACE].length)
		tt_aV[TITLEFONTFACE] = tt_aV[FONTFACE];
	if(!tt_aV[TITLEFONTSIZE].length)
		tt_aV[TITLEFONTSIZE] = tt_aV[FONTSIZE];
	if(tt_aV[CLOSEBTN])
	{
		// Use title colours for non-specified closebutton colours
		if(!tt_aV[CLOSEBTNCOLORS])
			tt_aV[CLOSEBTNCOLORS] = new Array("", "", "", "");
		for(var i = 4; i;)
		{--i;
			if(!tt_aV[CLOSEBTNCOLORS][i].length)
				tt_aV[CLOSEBTNCOLORS][i] = (i & 1) ? tt_aV[TITLEFONTCOLOR] : tt_aV[TITLEBGCOLOR];
		}
		// Enforce titlebar be shown
		if(!tt_aV[TITLE].length)
			tt_aV[TITLE] = " ";
	}
	// Circumvents broken display of images and fade-in flicker in Geckos < 1.8
	if(tt_aV[OPACITY] == 100 && typeof tt_aElt[0].style.MozOpacity != tt_u && !Array.every)
		tt_aV[OPACITY] = 99;
	// Smartly shorten the delay for fade-in tooltips
	if(tt_aV[FADEIN] && tt_flagOpa && tt_aV[DELAY] > 100)
		tt_aV[DELAY] = Math.max(tt_aV[DELAY] - tt_aV[FADEIN], 100);
}
function tt_AdaptConfig2()
{
	if(tt_aV[CENTERMOUSE])
	{
		tt_aV[OFFSETX] -= ((tt_w - (tt_aV[SHADOW] ? tt_aV[SHADOWWIDTH] : 0)) >> 1);
		tt_aV[JUMPHORZ] = false;
	}
}
// Expose content globally so extensions can modify it
function tt_MkTipContent(a)
{
	if(tt_t2t)
	{
		if(tt_aV[COPYCONTENT])
			tt_sContent = tt_t2t.innerHTML;
		else
			tt_sContent = "";
	}
	else
		tt_sContent = a[0];
	tt_ExtCallFncs(0, "CreateContentString");
}
function tt_MkTipSubDivs()
{
	var sCss = 'position:relative;margin:0px;padding:0px;border-width:0px;left:0px;top:0px;line-height:normal;width:auto;',
	sTbTrTd = ' cellspacing="0" cellpadding="0" border="0" style="' + sCss + '"><tbody style="' + sCss + '"><tr><td ';

	tt_aElt[0].style.width = tt_GetClientW() + "px";
	tt_aElt[0].innerHTML =
		(''
		+ (tt_aV[TITLE].length ?
			('<div id="WzTiTl" style="position:relative;z-index:1;">'
			+ '<table id="WzTiTlTb"' + sTbTrTd + 'id="WzTiTlI" style="' + sCss + '">'
			+ tt_aV[TITLE]
			+ '</td>'
			+ (tt_aV[CLOSEBTN] ?
				('<td align="right" style="' + sCss
				+ 'text-align:right;">'
				+ '<span id="WzClOsE" style="position:relative;left:2px;padding-left:2px;padding-right:2px;'
				+ 'cursor:' + (tt_ie ? 'hand' : 'pointer')
				+ ';" onmouseover="tt_OnCloseBtnOver(1)" onmouseout="tt_OnCloseBtnOver(0)" onclick="tt_HideInit()">'
				+ tt_aV[CLOSEBTNTEXT]
				+ '</span></td>')
				: '')
			+ '</tr></tbody></table></div>')
			: '')
		+ '<div id="WzBoDy" style="position:relative;z-index:0;">'
		+ '<table' + sTbTrTd + 'id="WzBoDyI" style="' + sCss + '">'
		+ tt_sContent
		+ '</td></tr></tbody></table></div>'
		+ (tt_aV[SHADOW]
			? ('<div id="WzTtShDwR" style="position:absolute;overflow:hidden;"></div>'
				+ '<div id="WzTtShDwB" style="position:relative;overflow:hidden;"></div>')
			: '')
		);
	tt_GetSubDivRefs();
	// Convert DOM node to tip
	if(tt_t2t && !tt_aV[COPYCONTENT])
		tt_El2Tip();
	tt_ExtCallFncs(0, "SubDivsCreated");
}
function tt_GetSubDivRefs()
{
	var aId = new Array("WzTiTl", "WzTiTlTb", "WzTiTlI", "WzClOsE", "WzBoDy", "WzBoDyI", "WzTtShDwB", "WzTtShDwR");

	for(var i = aId.length; i; --i)
		tt_aElt[i] = tt_GetElt(aId[i - 1]);
}
function tt_FormatTip()
{
	var css, w, h, pad = tt_aV[PADDING], padT, wBrd = tt_aV[BORDERWIDTH],
	iOffY, iOffSh, iAdd = (pad + wBrd) << 1;

	//--------- Title DIV ----------
	if(tt_aV[TITLE].length)
	{
		padT = tt_aV[TITLEPADDING];
		css = tt_aElt[1].style;
		css.background = tt_aV[TITLEBGCOLOR];
		css.paddingTop = css.paddingBottom = padT + "px";
		css.paddingLeft = css.paddingRight = (padT + 2) + "px";
		css = tt_aElt[3].style;
		css.color = tt_aV[TITLEFONTCOLOR];
		if(tt_aV[WIDTH] == -1)
			css.whiteSpace = "nowrap";
		css.fontFamily = tt_aV[TITLEFONTFACE];
		css.fontSize = tt_aV[TITLEFONTSIZE];
		css.fontWeight = "bold";
		css.textAlign = tt_aV[TITLEALIGN];
		// Close button DIV
		if(tt_aElt[4])
		{
			css = tt_aElt[4].style;
			css.background = tt_aV[CLOSEBTNCOLORS][0];
			css.color = tt_aV[CLOSEBTNCOLORS][1];
			css.fontFamily = tt_aV[TITLEFONTFACE];
			css.fontSize = tt_aV[TITLEFONTSIZE];
			css.fontWeight = "bold";
		}
		if(tt_aV[WIDTH] > 0)
			tt_w = tt_aV[WIDTH];
		else
		{
			tt_w = tt_GetDivW(tt_aElt[3]) + tt_GetDivW(tt_aElt[4]);
			// Some spacing between title DIV and closebutton
			if(tt_aElt[4])
				tt_w += pad;
			// Restrict auto width to max width
			if(tt_aV[WIDTH] < -1 && tt_w > -tt_aV[WIDTH])
				tt_w = -tt_aV[WIDTH];
		}
		// Ensure the top border of the body DIV be covered by the title DIV
		iOffY = -wBrd;
	}
	else
	{
		tt_w = 0;
		iOffY = 0;
	}

	//-------- Body DIV ------------
	css = tt_aElt[5].style;
	css.top = iOffY + "px";
	if(wBrd)
	{
		css.borderColor = tt_aV[BORDERCOLOR];
		css.borderStyle = tt_aV[BORDERSTYLE];
		css.borderWidth = wBrd + "px";
	}
	if(tt_aV[BGCOLOR].length)
		css.background = tt_aV[BGCOLOR];
	if(tt_aV[BGIMG].length)
		css.backgroundImage = "url(" + tt_aV[BGIMG] + ")";
	css.padding = pad + "px";
	css.textAlign = tt_aV[TEXTALIGN];
	if(tt_aV[HEIGHT])
	{
		css.overflow = "auto";
		if(tt_aV[HEIGHT] > 0)
			css.height = (tt_aV[HEIGHT] + iAdd) + "px";
		else
			tt_h = iAdd - tt_aV[HEIGHT];
	}
	// TD inside body DIV
	css = tt_aElt[6].style;
	css.color = tt_aV[FONTCOLOR];
	css.fontFamily = tt_aV[FONTFACE];
	css.fontSize = tt_aV[FONTSIZE];
	css.fontWeight = tt_aV[FONTWEIGHT];
	css.textAlign = tt_aV[TEXTALIGN];
	if(tt_aV[WIDTH] > 0)
		w = tt_aV[WIDTH];
	// Width like title (if existent)
	else if(tt_aV[WIDTH] == -1 && tt_w)
		w = tt_w;
	else
	{
		// Measure width of the body's inner TD, as some browsers would expand
		// the container and outer body DIV to 100%
		w = tt_GetDivW(tt_aElt[6]);
		// Restrict auto width to max width
		if(tt_aV[WIDTH] < -1 && w > -tt_aV[WIDTH])
			w = -tt_aV[WIDTH];
	}
	if(w > tt_w)
		tt_w = w;
	tt_w += iAdd;

	//--------- Shadow DIVs ------------
	if(tt_aV[SHADOW])
	{
		tt_w += tt_aV[SHADOWWIDTH];
		iOffSh = Math.floor((tt_aV[SHADOWWIDTH] * 4) / 3);
		// Bottom shadow
		css = tt_aElt[7].style;
		css.top = iOffY + "px";
		css.left = iOffSh + "px";
		css.width = (tt_w - iOffSh - tt_aV[SHADOWWIDTH]) + "px";
		css.height = tt_aV[SHADOWWIDTH] + "px";
		css.background = tt_aV[SHADOWCOLOR];
		// Right shadow
		css = tt_aElt[8].style;
		css.top = iOffSh + "px";
		css.left = (tt_w - tt_aV[SHADOWWIDTH]) + "px";
		css.width = tt_aV[SHADOWWIDTH] + "px";
		css.background = tt_aV[SHADOWCOLOR];
	}
	else
		iOffSh = 0;

	//-------- Container DIV -------
	tt_SetTipOpa(tt_aV[FADEIN] ? 0 : tt_aV[OPACITY]);
	tt_FixSize(iOffY, iOffSh);
}
// Fixate the size so it can't dynamically change while the tooltip is moving.
function tt_FixSize(iOffY, iOffSh)
{
	var wIn, wOut, h, add, pad = tt_aV[PADDING], wBrd = tt_aV[BORDERWIDTH], i;

	tt_aElt[0].style.width = tt_w + "px";
	tt_aElt[0].style.pixelWidth = tt_w;
	wOut = tt_w - ((tt_aV[SHADOW]) ? tt_aV[SHADOWWIDTH] : 0);
	// Body
	wIn = wOut;
	if(!tt_bBoxOld)
		wIn -= (pad + wBrd) << 1;
	tt_aElt[5].style.width = wIn + "px";
	// Title
	if(tt_aElt[1])
	{
		wIn = wOut - ((tt_aV[TITLEPADDING] + 2) << 1);
		if(!tt_bBoxOld)
			wOut = wIn;
		tt_aElt[1].style.width = wOut + "px";
		tt_aElt[2].style.width = wIn + "px";
	}
	// Max height specified
	if(tt_h)
	{
		h = tt_GetDivH(tt_aElt[5]);
		if(h > tt_h)
		{
			if(!tt_bBoxOld)
				tt_h -= (pad + wBrd) << 1;
			tt_aElt[5].style.height = tt_h + "px";
		}
	}
	tt_h = tt_GetDivH(tt_aElt[0]) + iOffY;
	// Right shadow
	if(tt_aElt[8])
		tt_aElt[8].style.height = (tt_h - iOffSh) + "px";
	i = tt_aElt.length - 1;
	if(tt_aElt[i])
	{
		tt_aElt[i].style.width = tt_w + "px";
		tt_aElt[i].style.height = tt_h + "px";
	}
}
function tt_DeAlt(el)
{
	var aKid;

	if(el)
	{
		if(el.alt)
			el.alt = "";
		if(el.title)
			el.title = "";
		aKid = el.childNodes || el.children || null;
		if(aKid)
		{
			for(var i = aKid.length; i;)
				tt_DeAlt(aKid[--i]);
		}
	}
}
// This hack removes the native tooltips over links in Opera
function tt_OpDeHref(el)
{
	if(!tt_op)
		return;
	if(tt_elDeHref)
		tt_OpReHref();
	while(el)
	{
		if(el.hasAttribute && el.hasAttribute("href"))
		{
			el.t_href = el.getAttribute("href");
			el.t_stats = window.status;
			el.removeAttribute("href");
			el.style.cursor = "hand";
			tt_AddEvtFnc(el, "mousedown", tt_OpReHref);
			window.status = el.t_href;
			tt_elDeHref = el;
			break;
		}
		el = tt_GetDad(el);
	}
}
function tt_OpReHref()
{
	if(tt_elDeHref)
	{
		tt_elDeHref.setAttribute("href", tt_elDeHref.t_href);
		tt_RemEvtFnc(tt_elDeHref, "mousedown", tt_OpReHref);
		window.status = tt_elDeHref.t_stats;
		tt_elDeHref = null;
	}
}
function tt_El2Tip()
{
	var css = tt_t2t.style;

	// Store previous positioning
	tt_t2t.t_cp = css.position;
	tt_t2t.t_cl = css.left;
	tt_t2t.t_ct = css.top;
	tt_t2t.t_cd = css.display;
	// Store the tag's parent element so we can restore that DOM branch
	// when the tooltip is being hidden
	tt_t2tDad = tt_GetDad(tt_t2t);
	tt_MovDomNode(tt_t2t, tt_t2tDad, tt_aElt[6]);
	css.display = "block";
	css.position = "static";
	css.left = css.top = css.marginLeft = css.marginTop = "0px";
}
function tt_UnEl2Tip()
{
	// Restore positioning and display
	var css = tt_t2t.style;

	css.display = tt_t2t.t_cd;
	tt_MovDomNode(tt_t2t, tt_GetDad(tt_t2t), tt_t2tDad);
	css.position = tt_t2t.t_cp;
	css.left = tt_t2t.t_cl;
	css.top = tt_t2t.t_ct;
	tt_t2tDad = null;
}
function tt_OverInit()
{
	if(window.event)
		tt_over = window.event.target || window.event.srcElement;
	else
		tt_over = tt_ovr_;
	tt_DeAlt(tt_over);
	tt_OpDeHref(tt_over);
}
function tt_ShowInit()
{
	tt_tShow.Timer("tt_Show()", tt_aV[DELAY], true);
	if(tt_aV[CLICKCLOSE] || tt_aV[CLICKSTICKY])
		tt_AddEvtFnc(document, "mouseup", tt_OnLClick);
}
function tt_Show()
{
	var css = tt_aElt[0].style;

	// Override the z-index of the topmost wz_dragdrop.js D&D item
	css.zIndex = Math.max((window.dd && dd.z) ? (dd.z + 2) : 0, 1010);
	if(tt_aV[STICKY] || !tt_aV[FOLLOWMOUSE])
		tt_iState &= ~0x4;
	if(tt_aV[EXCLUSIVE])
		tt_iState |= 0x8;
	if(tt_aV[DURATION] > 0)
		tt_tDurt.Timer("tt_HideInit()", tt_aV[DURATION], true);
	tt_ExtCallFncs(0, "Show")
	css.visibility = "visible";
	tt_iState |= 0x2;
	if(tt_aV[FADEIN])
		tt_Fade(0, 0, tt_aV[OPACITY], Math.round(tt_aV[FADEIN] / tt_aV[FADEINTERVAL]));
	tt_ShowIfrm();
}
function tt_ShowIfrm()
{
	if(tt_ie56)
	{
		var ifrm = tt_aElt[tt_aElt.length - 1];
		if(ifrm)
		{
			var css = ifrm.style;
			css.zIndex = tt_aElt[0].style.zIndex - 1;
			css.display = "block";
		}
	}
}
function tt_Move(e)
{
	if(e)
		tt_ovr_ = e.target || e.srcElement;
	e = e || window.event;
	if(e)
	{
		tt_musX = tt_GetEvtX(e);
		tt_musY = tt_GetEvtY(e);
	}
	if(tt_iState & 0x4)
	{
		// Prevent jam of mousemove events
		if(!tt_op && !tt_ie)
		{
			if(tt_bWait)
				return;
			tt_bWait = true;
			tt_tWaitMov.Timer("tt_bWait = false;", 1, true);
		}
		if(tt_aV[FIX])
		{
			tt_iState &= ~0x4;
			tt_PosFix();
		}
		else if(!tt_ExtCallFncs(e, "MoveBefore"))
			tt_SetTipPos(tt_Pos(0), tt_Pos(1));
		tt_ExtCallFncs([tt_musX, tt_musY], "MoveAfter")
	}
}
function tt_Pos(iDim)
{
	var iX, bJmpMod, cmdAlt, cmdOff, cx, iMax, iScrl, iMus, bJmp;

	// Map values according to dimension to calculate
	if(iDim)
	{
		bJmpMod = tt_aV[JUMPVERT];
		cmdAlt = ABOVE;
		cmdOff = OFFSETY;
		cx = tt_h;
		iMax = tt_maxPosY;
		iScrl = tt_GetScrollY();
		iMus = tt_musY;
		bJmp = tt_bJmpVert;
	}
	else
	{
		bJmpMod = tt_aV[JUMPHORZ];
		cmdAlt = LEFT;
		cmdOff = OFFSETX;
		cx = tt_w;
		iMax = tt_maxPosX;
		iScrl = tt_GetScrollX();
		iMus = tt_musX;
		bJmp = tt_bJmpHorz;
	}
	if(bJmpMod)
	{
		if(tt_aV[cmdAlt] && (!bJmp || tt_CalcPosAlt(iDim) >= iScrl + 16))
			iX = tt_PosAlt(iDim);
		else if(!tt_aV[cmdAlt] && bJmp && tt_CalcPosDef(iDim) > iMax - 16)
			iX = tt_PosAlt(iDim);
		else
			iX = tt_PosDef(iDim);
	}
	else
	{
		iX = iMus;
		if(tt_aV[cmdAlt])
			iX -= cx + tt_aV[cmdOff] - (tt_aV[SHADOW] ? tt_aV[SHADOWWIDTH] : 0);
		else
			iX += tt_aV[cmdOff];
	}
	// Prevent tip from extending past clientarea boundary
	if(iX > iMax)
		iX = bJmpMod ? tt_PosAlt(iDim) : iMax;
	// In case of insufficient space on both sides, ensure the left/upper part
	// of the tip be visible
	if(iX < iScrl)
		iX = bJmpMod ? tt_PosDef(iDim) : iScrl;
	return iX;
}
function tt_PosDef(iDim)
{
	if(iDim)
		tt_bJmpVert = tt_aV[ABOVE];
	else
		tt_bJmpHorz = tt_aV[LEFT];
	return tt_CalcPosDef(iDim);
}
function tt_PosAlt(iDim)
{
	if(iDim)
		tt_bJmpVert = !tt_aV[ABOVE];
	else
		tt_bJmpHorz = !tt_aV[LEFT];
	return tt_CalcPosAlt(iDim);
}
function tt_CalcPosDef(iDim)
{
	return iDim ? (tt_musY + tt_aV[OFFSETY]) : (tt_musX + tt_aV[OFFSETX]);
}
function tt_CalcPosAlt(iDim)
{
	var cmdOff = iDim ? OFFSETY : OFFSETX;
	var dx = tt_aV[cmdOff] - (tt_aV[SHADOW] ? tt_aV[SHADOWWIDTH] : 0);
	if(tt_aV[cmdOff] > 0 && dx <= 0)
		dx = 1;
	return((iDim ? (tt_musY - tt_h) : (tt_musX - tt_w)) - dx);
}
function tt_PosFix()
{
	var iX, iY;

	if(typeof(tt_aV[FIX][0]) == "number")
	{
		iX = tt_aV[FIX][0];
		iY = tt_aV[FIX][1];
	}
	else
	{
		if(typeof(tt_aV[FIX][0]) == "string")
			el = tt_GetElt(tt_aV[FIX][0]);
		// First slot in array is direct reference to HTML element
		else
			el = tt_aV[FIX][0];
		iX = tt_aV[FIX][1];
		iY = tt_aV[FIX][2];
		// By default, vert pos is related to bottom edge of HTML element
		if(!tt_aV[ABOVE] && el)
			iY += tt_GetDivH(el);
		for(; el; el = el.offsetParent)
		{
			iX += el.offsetLeft || 0;
			iY += el.offsetTop || 0;
		}
	}
	// For a fixed tip positioned above the mouse, use the bottom edge as anchor
	// (recommended by Christophe Rebeschini, 31.1.2008)
	if(tt_aV[ABOVE])
		iY -= tt_h;
	tt_SetTipPos(iX, iY);
}
function tt_Fade(a, now, z, n)
{
	if(n)
	{
		now += Math.round((z - now) / n);
		if((z > a) ? (now >= z) : (now <= z))
			now = z;
		else
			tt_tFade.Timer(
				"tt_Fade("
				+ a + "," + now + "," + z + "," + (n - 1)
				+ ")",
				tt_aV[FADEINTERVAL],
				true
			);
	}
	now ? tt_SetTipOpa(now) : tt_Hide();
}
function tt_SetTipOpa(opa)
{
	// To circumvent the opacity nesting flaws of IE, we set the opacity
	// for each sub-DIV separately, rather than for the container DIV.
	tt_SetOpa(tt_aElt[5], opa);
	if(tt_aElt[1])
		tt_SetOpa(tt_aElt[1], opa);
	if(tt_aV[SHADOW])
	{
		opa = Math.round(opa * 0.8);
		tt_SetOpa(tt_aElt[7], opa);
		tt_SetOpa(tt_aElt[8], opa);
	}
}
function tt_OnCloseBtnOver(iOver)
{
	var css = tt_aElt[4].style;

	iOver <<= 1;
	css.background = tt_aV[CLOSEBTNCOLORS][iOver];
	css.color = tt_aV[CLOSEBTNCOLORS][iOver + 1];
}
function tt_OnLClick(e)
{
	//  Ignore right-clicks
	e = e || window.event;
	if(!((e.button && e.button & 2) || (e.which && e.which == 3)))
	{
		if(tt_aV[CLICKSTICKY] && (tt_iState & 0x4))
		{
			tt_aV[STICKY] = true;
			tt_iState &= ~0x4;
		}
		else if(tt_aV[CLICKCLOSE])
			tt_HideInit();
	}
}
function tt_Int(x)
{
	var y;

	return(isNaN(y = parseInt(x)) ? 0 : y);
}
Number.prototype.Timer = function(s, iT, bUrge)
{
	if(!this.value || bUrge)
		this.value = window.setTimeout(s, iT);
}
Number.prototype.EndTimer = function()
{
	if(this.value)
	{
		window.clearTimeout(this.value);
		this.value = 0;
	}
}
function tt_GetWndCliSiz(s)
{
	var db, y = window["inner" + s], sC = "client" + s, sN = "number";
	if(typeof y == sN)
	{
		var y2;
		return(
			// Gecko or Opera with scrollbar
			// ... quirks mode
			((db = document.body) && typeof(y2 = db[sC]) == sN && y2 &&  y2 <= y) ? y2 
			// ... strict mode
			: ((db = document.documentElement) && typeof(y2 = db[sC]) == sN && y2 && y2 <= y) ? y2
			// No scrollbar, or clientarea size == 0, or other browser (KHTML etc.)
			: y
		);
	}
	// IE
	return(
		// document.documentElement.client+s functional, returns > 0
		((db = document.documentElement) && (y = db[sC])) ? y
		// ... not functional, in which case document.body.client+s 
		// is the clientarea size, fortunately
		: document.body[sC]
	);
}
function tt_SetOpa(el, opa)
{
	var css = el.style;

	tt_opa = opa;
	if(tt_flagOpa == 1)
	{
		if(opa < 100)
		{
			// Hacks for bugs of IE:
			// 1.) Once a CSS filter has been applied, fonts are no longer
			// anti-aliased, so we store the previous 'non-filter' to be
			// able to restore it
			if(typeof(el.filtNo) == tt_u)
				el.filtNo = css.filter;
			// 2.) A DIV cannot be made visible in a single step if an
			// opacity < 100 has been applied while the DIV was hidden
			var bVis = css.visibility != "hidden";
			// 3.) In IE6, applying an opacity < 100 has no effect if the
			//	   element has no layout (position, size, zoom, ...)
			css.zoom = "100%";
			if(!bVis)
				css.visibility = "visible";
			css.filter = "alpha(opacity=" + opa + ")";
			if(!bVis)
				css.visibility = "hidden";
		}
		else if(typeof(el.filtNo) != tt_u)
			// Restore 'non-filter'
			css.filter = el.filtNo;
	}
	else
	{
		opa /= 100.0;
		switch(tt_flagOpa)
		{
		case 2:
			css.KhtmlOpacity = opa; break;
		case 3:
			css.KHTMLOpacity = opa; break;
		case 4:
			css.MozOpacity = opa; break;
		case 5:
			css.opacity = opa; break;
		}
	}
}
function tt_Err(sErr, bIfDebug)
{
	if(tt_Debug || !bIfDebug)
		alert("Tooltip Script Error Message:\n\n" + sErr);
}

//============  EXTENSION (PLUGIN) MANAGER  ===============//
function tt_ExtCmdEnum()
{
	var s;

	// Add new command(s) to the commands enum
	for(var i in config)
	{
		s = "window." + i.toString().toUpperCase();
		if(eval("typeof(" + s + ") == tt_u"))
		{
			eval(s + " = " + tt_aV.length);
			tt_aV[tt_aV.length] = null;
		}
	}
}
function tt_ExtCallFncs(arg, sFnc)
{
	var b = false;
	for(var i = tt_aExt.length; i;)
	{--i;
		var fnc = tt_aExt[i]["On" + sFnc];
		// Call the method the extension has defined for this event
		if(fnc && fnc(arg))
			b = true;
	}
	return b;
}

tt_Init();


</script>



<script type="text/javascript">

////////////////////////////////////////////////////////////////////////////////////
// external inputs
////////////////////////////////////////////////////////////////////////////////////

var chartName = '01_cholitas_VC';
var outWidth = 800;
var outHeight = 600;
var stimArray = new Array('01_cholitas.jpg');
var dataArray = new Array();
dataArray[0] = new Array();
dataArray[0][0] = new Array();
dataArray[0][0][0] = 'VC';
dataArray[0][0][1] = new Array('01_cholitas_VC0000',251,225,0,317,529,'01_cholitas_VC0001',514,232,0,646,942,'01_cholitas_VC0002',632,264,0,1037,1200,'01_cholitas_VC0003',216,261,0,1471,1579,'01_cholitas_VC0004',155,483,0,1696,1858,'01_cholitas_VC0005',98,448,0,1958,2233,'01_cholitas_VC0006',309,556,0,2346,2429,'01_cholitas_VC0007',390,253,0,2638,2738,'01_cholitas_VC0008',256,237,0,2917,3058,'01_cholitas_VC0009',589,506,0,3312,3558,'01_cholitas_VC0010',516,592,0,3721,3758,'01_cholitas_VC0011',764,425,0,3896,4229,'01_cholitas_VC0012',113,315,0,4412,4692,'01_cholitas_VC0013',161,456,0,4975,5312,'01_cholitas_VC0014',97,464,0,5404,5675,'01_cholitas_VC0015',118,326,0,5775,6171,'01_cholitas_VC0016',424,147,0,6675,6908,'01_cholitas_VC0017',258,232,0,7012,7317,'01_cholitas_VC0018',628,256,0,7458,7771,'01_cholitas_VC0019',673,382,0,7871,8137,'01_cholitas_VC0020',579,593,0,8250,8300,'01_cholitas_VC0021',580,593,0,8346,8437,'01_cholitas_VC0022',253,244,0,8587,8696,'01_cholitas_VC0023',221,237,0,8775,8992,'01_cholitas_VC0024',109,465,0,9100,9254,'01_cholitas_VC0025',353,236,0,9612,9733,'01_cholitas_VC0026',555,312,0,9837,10037,'01_cholitas_VC0027',507,472,0,10133,10150,'01_cholitas_VC0028',592,278,0,10279,10483,'01_cholitas_VC0029',586,220,0,10567,10942,'01_cholitas_VC0030',540,300,0,11033,11333,'01_cholitas_VC0031',589,242,0,11421,11800,'01_cholitas_VC0032',321,292,0,12012,12242,'01_cholitas_VC0033',453,217,0,12342,12683,'01_cholitas_VC0034',401,286,0,12767,12883,'01_cholitas_VC0035',381,299,0,13083,13542,'01_cholitas_VC0036',415,228,0,13866,13975,'01_cholitas_VC0037',475,207,0,14066,14279,'01_cholitas_VC0038',468,211,0,14312,14675,'01_cholitas_VC0039',653,276,0,14891,15166,'01_cholitas_VC0040',657,477,0,15275,15416,'01_cholitas_VC0041',630,549,0,15516,15579,'01_cholitas_VC0042',612,105,0,15921,16025,'01_cholitas_VC0043',685,310,0,16225,16292,'01_cholitas_VC0044',231,233,0,16717,16812,'01_cholitas_VC0045',624,157,0,16983,17071,'01_cholitas_VC0046',623,154,0,17129,17342,'01_cholitas_VC0047',704,328,0,17446,17729,'01_cholitas_VC0048',611,268,0,18004,18242,'01_cholitas_VC0049',682,316,0,18488,18763,'01_cholitas_VC0050',645,557,0,18871,19159,'01_cholitas_VC0051',615,559,0,19205,19605,'01_cholitas_VC0052',634,174,0,20042,20138,'01_cholitas_VC0053',580,239,0,20322,20497,'01_cholitas_VC0054',120,444,0,20705,20859,'01_cholitas_VC0055',63,432,0,21055,21238,'01_cholitas_VC0056',45,417,0,21288,21580,'01_cholitas_VC0057',242,174,0,21705,21839,'01_cholitas_VC0058',216,224,0,22034,22247,'01_cholitas_VC0059',58,496,0,22464,22468,'01_cholitas_VC0060',53,443,0,22501,22980,'01_cholitas_VC0061',134,421,0,23076,23410,'01_cholitas_VC0062',745,478,0,23606,23751,'01_cholitas_VC0063',694,183,0,23881,24031,'01_cholitas_VC0064',767,490,0,24143,24268,'01_cholitas_VC0065',776,470,0,24318,25014,'01_cholitas_VC0066',216,247,0,25377,25789,'01_cholitas_VC0067',111,229,0,25885,26102,'01_cholitas_VC0068',684,237,0,26310,26444,'01_cholitas_VC0069',676,239,0,26481,26573,'01_cholitas_VC0070',773,200,0,26794,27206,'01_cholitas_VC0071',769,214,0,27252,27598,'01_cholitas_VC0072',793,208,0,27644,27761,'01_cholitas_VC0073',791,207,0,27794,27982,'01_cholitas_VC0074',448,396,0,28136,28327,'01_cholitas_VC0075',427,554,0,28423,28582,'01_cholitas_VC0076',540,520,0,28686,28982,'01_cholitas_VC0077',268,495,0,29094,29153,'01_cholitas_VC0078',229,223,0,29411,29532,'01_cholitas_VC0079',230,238,0,29578,29928,'01_cholitas_VC0080',411,383,0,30040,30140,'01_cholitas_VC0081',271,377,0,30245,30428,'01_cholitas_VC0082',283,353,0,30474,30845,'01_cholitas_VC0083',211,486,0,30978,31311,'01_cholitas_VC0084',271,553,0,31395,31770,'01_cholitas_VC0085',370,315,0,32162,32491,'01_cholitas_VC0086',770,185,0,32861,32953,'01_cholitas_VC0087',437,199,0,33124,33211);
dataArray[0][0][2] = new Array();
dataArray[0][0][3] = new Array();
dataArray[0][0][4] = new Array('um',0,2078,2659,'there are two women',0,2659,4211,'fighting in some kind of',0,4211,5873,'like boxing or wrestling ring',0,5873,8144,'um one',0,8283,9114,'of the ladies is kicking the other one in midair',0,9252,12327,'um and her',0,12549,13214,'skirt is flying up',0,14017,15818,'uh',0,16178,16787,'y-',0,16787,17203,'the other lady is being kicked',0,17203,19502,'um and it looks like she\'s about to fall over',0,19502,21912,'um there\'s some people watch in the background',0,22411,24932,'some people taking pictures',0,24932,26704,'um and a basketball hoop on the side',0,27258,30527);
dataArray[0][0][5] = new Array();
dataArray[0][0][6] = new Array();


////////////////////////////////////////////////////////////////////////////////////
// constants
////////////////////////////////////////////////////////////////////////////////////
var padding = 8;

var axisHeight = 16;
var blockHeight = 15;
var wordHeight = 12;
var scaleHeight = 10;
var sectHeight = 16;
var headHeight = 25;
var tagHeight = 40;

var imageWidth = outWidth * 70 / 100;
var imageHeight = outHeight * 70 / 100;

var subjectLayout;
var stimulusOrient;
var tallView;
var thumbWidth;
var thumbHeight;
var gridWidth;

var minPeriod, maxPeriod;
var canvasWidth;
var tagWidth;

// for tag correlation
var fixationYPos, transcriptYPos;
var fixationAxisDrawn, transcriptAxisDrawn;
var fixationArray, transcriptArray;

// create jsGraphic object
var jg = new jsGraphics( "chart" );

// configure tooltip object
config.FadeIn = 0;
config.FadeOut = 0;
config.Delay = 0;


////////////////////////////////////////////////////////////////////////////////////
// sub-functions
////////////////////////////////////////////////////////////////////////////////////

function timeStamp( startTime, endTime, txt )
{
	var sttime = startTime / 1000;
	var edtime = endTime / 1000;
	var drtime = edtime - sttime;
	var stmin = Math.floor(sttime / 60);
	var edmin = Math.floor(edtime / 60);
	var drmin = Math.floor(drtime / 60);
	var stsec = sttime - stmin * 60;
	var edsec = edtime - edmin * 60;
	var drsec = drtime - drmin * 60;

	if( stmin > 0 )
		txt += stmin + ':';
	txt += stsec.toFixed(3);
	txt += ' ~ '
	if( edmin > 0 )
		txt += edmin + ':';
	txt += edsec.toFixed(3);
	txt += ' [';
	if( drmin > 0 )
		txt += drmin + ':';
	txt += drsec.toFixed(3);
	txt += ']';
	
	return txt;
}

function imageTooltip( startTime, endTime, img, desc )
{
	txt = '';
	txt = timeStamp( startTime, endTime, txt );

	txt += ' -- \'' + img.replace(/^.*\//, '') + '\'';
	txt += '<br><img src=' + escape( img );
	txt += ' width="' + imageWidth + '" height="' + imageHeight + '">';

	if( desc != '' )
		txt += '<br><b>' + desc + '</b>';

	return txt;
}

function wordTooltip( startTime, endTime, word )
{
	txt = '';
	txt = timeStamp( startTime, endTime, txt );

	txt += '<br><b>"' + word + '"</b>';

	return txt; 
}

function getBlkCoords( seqArray, seqSize )
{
	var coordArray = new Array( (seqArray.length / seqSize) * 4 );

	for( i = 0; i < seqArray.length / seqSize; i ++ )
	{
		var stPos = (seqArray[i * seqSize + seqSize - 2] / 1000 - minPeriod) * gridWidth;     // convert start time
		var edPos = (seqArray[i * seqSize + seqSize - 1] / 1000 - minPeriod) * gridWidth;     // convert end time
	
		// time block coordinates
		coordArray[i * 4] = seqArray[i * seqSize + seqSize - 3];    // shading option
		coordArray[i * 4 + 1] = stPos;  // x coordinate
		coordArray[i * 4 + 2] = 0;      // y coordinate (currently always 0)
		coordArray[i * 4 + 3] = edPos - stPos + 1;  // width
	}
	
	return coordArray;
}

function getImgCoords( imgAlign, seqArray, seqSize )
{
	var coordArray = new Array( (seqArray.length / seqSize) * 2 );

	var imgInterval = thumbWidth + padding;

	if( tallView )
		imgInterval = imgInterval / 2;
	
	var imgPos = -imgInterval;
	
	for( i = 0; i < seqArray.length / 3; i ++ )
	{
		var stPos = (seqArray[i * seqSize + seqSize - 2] / 1000 - minPeriod) * gridWidth;     // convert start time
		var edPos = (seqArray[i * seqSize + seqSize - 1] / 1000 - minPeriod) * gridWidth;     // convert end time
		var yOffset = 0;

		if( tallView )
		{
			if( i % 2 == 0 )
				yOffset = 0;
			else
				yOffset = thumbHeight + padding;
		}

		if( imgAlign == 1 )		// align images with the center of time blocks
			imgPos = Math.max(imgPos + imgInterval, (stPos + edPos) / 2 - thumbWidth / 2);

		if( imgAlign == 2 )		// align images with the beginning of time blocks
			imgPos = Math.max(imgPos + imgInterval, stPos - thumbWidth / 2);

		// image coords
		coordArray[i * 2] = imgPos;
		coordArray[i * 2 + 1] = yOffset;
	}

	return coordArray;
}


////////////////////////////////////////////////////////////////////////////////////
// drawing functions
////////////////////////////////////////////////////////////////////////////////////

var blockDrawn = false;
var axisDrawn = false;
var paddingPut = false;

function drawHeadline( jg, xPos, yPos, str )
{
	var yPosNext = yPos + headHeight + headHeight / 3;

	// draw BG
	jg.setColor( "lightsteelblue" );
//	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );
	jg.fillRect( 0, yPos, canvasWidth + xPos, yPosNext - yPos );

	// put headline
	jg.setColor( "black" );
	jg.setFont( "verdana", headHeight + "px", Font.BOLD );
	var strWidth = jg.stringWidth( str );
	jg.drawString( str, padding * 2, yPos );
	jg.drawString( str, (canvasWidth + xPos) / 2 - strWidth / 2, yPos );
	jg.drawString( str, canvasWidth + xPos - strWidth - padding * 2, yPos );

	// set sequence block variables
	blockDrawn = false;
	axisDrawn = false;
	paddingPut = false;
	
	// return next y coordinate
	return yPosNext;
}

function drawSection( jg, xPos, yPos, str )
{
	var yPosNext = yPos + sectHeight + sectHeight / 3;

	// draw BG
	jg.setColor( "#1C3448" );	// dark steel blue
	jg.fillRect( 0, yPos, canvasWidth + xPos, yPosNext - yPos );

	// put section names
	jg.setColor( "steelblue" );
	jg.setFont( "arial", sectHeight + "px", Font.BOLD );
	var strWidth = jg.stringWidth( str );
	jg.drawString( str, 0, yPos );	
	for( i = 1; i < 4; i ++ )
		jg.drawString( str, (canvasWidth + xPos) * i / 4 - strWidth / 2, yPos );
	jg.drawString( str, canvasWidth + xPos - strWidth, yPos );

	// set sequence block variables
	blockDrawn = false;
	axisDrawn = false;
	paddingPut = false;

	// return next y coordinate
	return yPosNext;
}

function drawTimeAxis( jg, xPos, yPos )
{
	var yPosNext = yPos + axisHeight + scaleHeight;
	
	yPosNext += padding;
	
	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );
	
	xPos += padding;

	var axisWidth = gridWidth * (maxPeriod - minPeriod + 1);
	
	var arrowWidth = gridWidth / 7;
	var arrowHeight = axisHeight - 2;
	
	// draw vertical lines
	jg.setColor( "black" );
	jg.setStroke( 2 );
	for( i = 0; i < maxPeriod - minPeriod + 1; i ++ )
		jg.drawLine( xPos + gridWidth * i, yPos, xPos + gridWidth * i, yPos + axisHeight );
	
	// draw horizontal line
	jg.drawLine( xPos, yPos + axisHeight / 2, xPos + axisWidth, yPos + axisHeight / 2 );
	
	// draw arrow head
	jg.setStroke( 1 );
	jg.fillPolygon( new Array( xPos + axisWidth - arrowWidth + 2,
										 xPos + axisWidth + 2,
										 xPos + axisWidth - arrowWidth + 2,
										 xPos + axisWidth - arrowWidth + 2 + 4 ),
					new Array( yPos + axisHeight / 2 - arrowHeight / 2 + 1,
										 yPos + axisHeight / 2 + 1,
										 yPos + axisHeight / 2 + arrowHeight / 2 + 1,
										 yPos + axisHeight / 2 + 1 ) );
	
	// put scales
	jg.setFont( "arial", scaleHeight + "px", Font.PLAIN );
	for( i = 0; i < maxPeriod - minPeriod + 1; i ++ )
		jg.drawString( i + minPeriod, xPos - scaleHeight / 4 + gridWidth * i, yPos + axisHeight );
		
	// set sequence block variable
	axisDrawn = true;
		
	// return next y coordinate
	return yPosNext;
}

function drawTimeBlocks( jg, xPos, yPos, blkCoords )
{
	var yPosNext = yPos + blockHeight + padding;
	
	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );

	xPos += padding;

	// put time blocks	
	for( i = 0; i < blkCoords.length / 4; i ++ )
	{
	    switch( blkCoords[i * 4] )
	    {
	    case 0: jg.setColor( "gray" ); break;
	    case 1: jg.setColor( "#A07070" ); break;	// grayish red
	    case 2: jg.setColor( "#7070A0" ); break;	// grayish blue
	    }
		jg.fillRect( xPos + blkCoords[i * 4 + 1], yPos + blkCoords[i * 4 + 2], blkCoords[i * 4 + 3], blockHeight );
		
		// draw boundary for overlapping blocks
		if( i > 0 )
		{
			j = i - 1;
			if( blkCoords[i * 4 + 2] == blkCoords[j * 4 + 2] &&     // check y-offset
			    blkCoords[j * 4 + 1] + blkCoords[j * 4 + 3] >= blkCoords[i * 4] )
			{
				jg.setColor( "darkgray" );
				jg.fillRect( xPos + blkCoords[i * 4 + 1], yPos + blkCoords[i * 4 + 2], 1, blockHeight );
			}
		}
	}
	
	return yPosNext;
}

function drawEyeSequence( jg, xPos, yPos, eyeArray )
{
	// get coordinates
	var blkCoords = getBlkCoords( eyeArray, 6 );
	var imgCoords = getImgCoords( 1, eyeArray, 6 );
	
	var yPosBlk;
	var yPosImg;
	
	if( axisDrawn )
	{
		yPosBlk = yPos;
		
		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}

	var yPosNext = yPos + thumbHeight + padding * 2;
	if( tallView )
		yPosNext += thumbHeight + padding;

	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );
	
	if( axisDrawn ) yPos += padding;

	yPosImg = yPos;	
	xPos += padding;		
	// put images
	for( i = 0; i < eyeArray.length / 6; i ++ )
	{
		var imgName = chartName + "_images/fx_" + eyeArray[i * 6] + ".jpg";
		var eventHandler = "onmouseover=\"Tip(imageTooltip(\'"
								+ eyeArray[i * 6 + 4] + "\', \'"	// start time
								+ eyeArray[i * 6 + 5] + "\', \'"	// end time
								+ imgName + "\', \'\'))\" onmouseout=\"UnTip()\"";

		jg.drawImage( imgName, xPos + imgCoords[i * 2], yPos + imgCoords[i * 2 + 1],
										thumbWidth, thumbHeight, eventHandler );
	}
	yPos += thumbHeight + padding;
	if( tallView )
		yPos += thumbHeight + padding;
	xPos -= padding;

	if( !axisDrawn )
	{
		yPos += padding;
		yPosBlk = yPos;

		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}

	xPos += padding;
	
	// draw fixation lines
	jg.setColor( "crimson" );
	jg.setStroke( 2 );
	for( i = 0; i < eyeArray.length / 6; i ++ )
	{
		var fixX = eyeArray[i * 6 + 1] * thumbWidth / outWidth;
		var fixY = eyeArray[i * 6 + 2] * thumbHeight / outHeight;
	   
		jg.drawLine( xPos + blkCoords[i * 4 + 1] + blkCoords[i * 4 + 3] / 2, yPosBlk + blkCoords[i * 4 + 2] + blockHeight / 2,
					 xPos + imgCoords[i * 2] + fixX, yPosImg + imgCoords[i * 2 + 1] + fixY );
	}
	
	// set sequence block variable
	blockDrawn = true;

	// return the next y coordinate
	return yPos;
}

function drawTagSequence( jg, xPos, yPos, tagArray )
{
	// get coordinates
	var blkCoords = getBlkCoords( tagArray, 5 );

	if( axisDrawn )
	{
		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}

	var yPosNext = yPos + wordHeight + padding;

	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );

	xPos += padding;
	// put tags
	for( i = 0; i < tagArray.length / 5; i ++ )
	{
		var wordFull = tagArray[i * 5 + 1];
		wordFull = wordFull.replace( /\'/g, "\\\'" );     // handle apostrophes
		
		var eventHandler = "onmouseover=\"Tip(wordTooltip(\'"
								+ tagArray[i * 5 + 3] + "\', \'"	// start time
								+ tagArray[i * 5 + 4] + "\', \'"	// end time
								+ wordFull + "\'))\" onmouseout=\"UnTip()\"";

		var word = tagArray[i * 5];
		word = word.replace( /\'/g, "\\\'" );   // handle apostrophes
		word = word.replace( /\\/g, "" );       // remove escape characters
		
		jg.setFont( "verdana", wordHeight + "px", Font.PLAIN );
		jg.setColor( "gray" );
		jg.drawString( word, xPos + blkCoords[i * 4 + 1], yPos );
		jg.setColor( "black" );
		jg.drawStringRect( word, xPos + blkCoords[i * 4 + 1], yPos, blkCoords[i * 4 + 3], "left", eventHandler );
	}
	yPos += wordHeight + padding;
	xPos -= padding;

	if( !axisDrawn )
	{
		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}
	
	// set sequence block variable
	blockDrawn = true;

	// return the next y coordinate
	return yPos;
}

function drawWordSequence( jg, xPos, yPos, wordArray )
{
	// get coordinates
	var blkCoords = getBlkCoords( wordArray, 4 );

	if( axisDrawn )
	{
		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}

	var yPosNext = yPos + wordHeight * 2 + padding;

	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );

	xPos += padding;

	// put words
	for( i = 0; i < wordArray.length / 4; i ++ )
	{
		var word = wordArray[i * 4];
		word = word.replace( /\'/g, "\\\'" );     // handle apostrophes
		
		var eventHandler = "onmouseover=\"Tip(wordTooltip(\'"
								+ wordArray[i * 4 + 2] + "\', \'"	// start time
								+ wordArray[i * 4 + 3] + "\', \'"	// end time
								+ word + "\'))\" onmouseout=\"UnTip()\"";

		word = word.replace( /\\/g, "" );     // remove escape characters
		
		jg.setColor( "black" );
		jg.setFont( "verdana", wordHeight + "px", Font.PLAIN );
		jg.drawStringRect( word, xPos + blkCoords[i * 4 + 1], yPos, blkCoords[i * 4 + 3], "center", eventHandler );
	}
	yPos += wordHeight * 2 + padding;
	xPos -= padding;

	if( !axisDrawn )
	{
		// draw time blocks
		yPos = drawTimeBlocks( jg, xPos, yPos, blkCoords );
	}
	
	// set sequence block variable
	blockDrawn = true;

	// return the next y coordinate
	return yPos;
}

function drawMultiwordSequence( jg, xPos, yPos, wordArray )
{
	// get max level
	var maxLvl = 0;
	for( i = 0; i < wordArray.length / 5; i ++ )
		if( wordArray[i * 5 + 1] > maxLvl ) maxLvl = wordArray[i * 5 + 1];
	
	// for each level
	for( lvl = 0; lvl <= maxLvl; lvl ++ )
	{
		// get sub word array
		var sArrayNum = 0;
		for( i = 0; i < wordArray.length / 5; i ++ )
			if( wordArray[i * 5 + 1] == lvl ) sArrayNum ++;
			
		var sWordArray = new Array( sArrayNum * 4 );
		for( i = 0, j = 0; i < wordArray.length / 5; i ++ )
		{
		    // copy each word block
			if( wordArray[i * 5 + 1] == lvl )
			{
				sWordArray[j * 4] = wordArray[i * 5];           // word
				sWordArray[j * 4 + 1] = wordArray[i * 5 + 2];   // shading
				sWordArray[j * 4 + 2] = wordArray[i * 5 + 3];   // start time
				sWordArray[j * 4 + 3] = wordArray[i * 5 + 4];   // end time
				j ++;
			}
		}
		
		// draw sub word sequence
		yPos = drawWordSequence( jg, xPos, yPos, sWordArray );
	}

	// return the next y coordinate
	return yPos;
}

function drawGraphSequence( jg, xPos, yPos, graphArray )
{
    //
    // this function is incorrect - it needs to be reprogrammed
    //

	var yPosNext = yPos + blockHeight * 2 + thumbHeight + padding * 2;
	if( tallView )
		yPosNext += thumbHeight + padding;

	yPosNext += padding;

	// draw BG
	jg.setColor( "white" );
	jg.fillRect( xPos, yPos, canvasWidth, yPosNext - yPos );

	xPos += padding;


	// get coordinates
	var blkCoords = getBlkCoords( graphArray, 5 );
	var	imgCoords = getImgCoords( 2, graphArray, 5 );

	for( i = 0; i < graphArray.length / 4; i ++ )
	{
		// adjust y coordinates
		if( axisDrawn )
		{
			// place time blocks above images
			imgCoords[i * 2 + 1] += blockHeight * 2 + padding * 2;
		} else
		{
			// place time blocks below images
			if( tallView )
				blkCoords[i * 4 + 2] += thumbHeight * 2 + padding * 3;
			else
				blkCoords[i * 4 + 2] += thumbHeight + padding * 2;
		}

		// draw time blocks
		jg.setColor( "gray" );
		jg.fillRect( blkCoords[i * 4 + 1], blkCoords[i * 4 + 2], blkCoords[i * 4 + 3], blockHeight );		
		if( i == 0 )	// draw dummy time block
			jg.fillRect( xPos, blkCoords[2] + blockHeight, blkCoords[1] - xPos, blockHeight );

		// draw connection lines
		jg.setColor( "#0080CE" );
		jg.setStroke( 2 );
		jg.drawLine( blkCoords[i * 4 + 1], blkCoords[i * 4 + 2] + blockHeight / 2,
					 imgCoords[i * 2] + thumbWidth / 2, imgCoords[i * 2 + 1] + thumbHeight / 2 );
					 
		// put images
		var imgName = chartName + "_images/sr_" + graphArray[i * 5] + ".jpg";
		var desc = graphArray[i * 5 + 1].replace( /\'/g, "\\\'" );     // handle apostrophes		
		var eventHandler = "onmouseover=\"Tip(imageTooltip(\'"
								+ graphArray[i * 5 + 3] + "\', \'"	// start time
								+ graphArray[i * 5 + 4] + "\', \'"	// end time
    							+ imgName + "', \'"
								+ desc + "\'))\" onmouseout=\"UnTip()\"";
	  															
		jg.drawImage( imgName, imgCoords[i * 2], imgCoords[i * 2 + 1],
											thumbWidth, thumbHeight, eventHandler );
	}
	
	// set sequence block variable
	blockDrawn = true;

	// return the next y coordinate
	return yPosNext;
}

function drawTagCorrelation( jg, xPos, yPosFix, yPosTrs, axisDrawnFix, axisDrawnTrs, corArray, fixArray, trsArray )
{
	// get coordinates
	var blkCoordsFix = getBlkCoords( fixArray, 5 );
	var blkCoordsTrs = getBlkCoords( trsArray, 5 );
	
	// adjust coordinates
	if( !axisDrawnFix ) yPosFix += padding + wordHeight;
	if( !axisDrawnTrs ) yPosTrs += padding + wordHeight * 2;
	xPos += padding;

	// draw correlation lines
    jg.setColor( "#20B2AA" );   // light sea green
    jg.setStroke( 2 );
	for( i = 0; i < corArray.length / 2; i ++ )
	{
	    var fixIdx = corArray[i * 2];
	    var trsIdx = corArray[i * 2 + 1];
	    
	    var yOffset = (padding * 2 + wordHeight * 2 + blockHeight) * trsArray[trsIdx * 5 + 1];
	    
	    jg.drawLine( xPos + blkCoordsFix[fixIdx * 4 + 1] + blkCoordsFix[fixIdx * 4 + 3] / 2, yPosFix + blkCoordsFix[fixIdx * 4 + 2] + blockHeight / 2,
	                 xPos + blkCoordsTrs[trsIdx * 4 + 1] + blkCoordsTrs[trsIdx * 4 + 3] / 2, yPosTrs + blkCoordsTrs[trsIdx * 4 + 2] + blockHeight / 2 + yOffset );
	}
}

function drawBlockSequence( jg, xPos, yPos, seqType, seqArray, tag )
{
	if( seqArray.length < 1 ) return yPos;

    var newBlock = false;
	if( seqType >= 1 && seqType <= 5 ) newBlock = true;

    if( newBlock )
    {
		if( tag.length > 0 ) xPos += tagWidth;
		
		if( !paddingPut )
		{
			// put padding
			jg.setColor( "white" );
			jg.fillRect( xPos, yPos, canvasWidth, padding );
		
			yPos += padding;
			
			paddingPut = true;
		}
	
		if( blockDrawn && !axisDrawn )
			yPos = drawTimeAxis( jg, xPos, yPos );
	}
	
	var yPosPrev = yPos;
		
	switch( seqType )
	{
	case 1:		// eye-trace
		yPos = drawEyeSequence( jg, xPos, yPos, seqArray );	
		break;
				
	case 2:		// fixation tag
        fixationYPos = yPos;
        fixationAxisDrawn = axisDrawn;
        fixationArray = seqArray;
		yPos = drawTagSequence( jg, xPos, yPos, seqArray );
		break;
		
	case 3:		// transcript tag
        transcriptYPos = yPos;
        transcriptAxisDrawn = axisDrawn;
        transcriptArray = seqArray;
	    yPos = drawMultiwordSequence( jg, xPos, yPos, seqArray );
	    break;
	    
	case 4:		// utterance
		yPos = drawWordSequence( jg, xPos, yPos, seqArray );
		break;
	
	case 5:		// SemRep
		yPos = drawGraphSequence( jg, xPos, yPos, seqArray );	
		break;

	case 6:		// tag correlation
	    drawTagCorrelation( jg, xPos, fixationYPos, transcriptYPos, fixationAxisDrawn, transcriptAxisDrawn,
	                        seqArray, fixationArray, transcriptArray );
		break;
	}
	
	if( newBlock )
	{
		if( tag.length > 0 )
		{
			// put block sequence tag
			jg.setColor( "lightgray" );
			jg.setFont( "tahoma", tagHeight + "px", Font.PLAIN );
			jg.drawStringRect( tag, xPos - tagWidth, yPos - (yPos - yPosPrev) / 2 - tagHeight / 2 - padding, tagWidth, "center", "" );
		}
	
		if( !axisDrawn )
			yPos = drawTimeAxis( jg, xPos, yPos );
		else
			axisDrawn = false;
	}
	
	return yPos;
}


////////////////////////////////////////////////////////////////////////////////////
// main drawing function
////////////////////////////////////////////////////////////////////////////////////


function drawChart()
{
	// initialize
	minPeriod = 1000000000;
	maxPeriod = 0;
	canvasWidth = 0;
	tagWidth = 0;
	
	jg.clear();

	var stimName;
	var subjectName;
	var seqArray;
	
	//
	// get the period range and tag width
	//
	for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
	{
		for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
		{
			subjectName = dataArray[stmIdx][sbjIdx][0];
			jg.setFont( "tahoma", tagHeight + "px", Font.PLAIN );
			tagWidth = Math.max( tagWidth, jg.stringWidth( subjectName ) );
			
			for( seq = 1; seq < 7; seq ++ )
			{
			    seqArray = dataArray[stmIdx][sbjIdx][seq];	    
			    if( seqArray.length <= 0 ) continue;
			    
			    switch( seq )
			    {
			    case 1:		// eye-trace
		            minPeriod = Math.min( minPeriod, Math.floor(seqArray[4] / 1000) );
			        maxPeriod = Math.max( maxPeriod, Math.ceil(seqArray[seqArray.length - 1] / 1000) );
	    			break;
	    			
	    		case 2:     // fixation tag
		            minPeriod = Math.min( minPeriod, Math.floor(seqArray[3] / 1000) );
			        maxPeriod = Math.max( maxPeriod, Math.ceil(seqArray[seqArray.length - 1] / 1000) );
	    			break;
	    			
	    		case 3:     // transcript tag
	    		    for( i = 0; i < seqArray.length / 5; i ++ )
	    		    {
   			            minPeriod = Math.min( minPeriod, Math.floor(seqArray[i * 5 + 3] / 1000) );
    			        maxPeriod = Math.max( maxPeriod, Math.ceil(seqArray[i * 5 + 4] / 1000) );
	    		    }
	    		    break;
	    		    
	    		case 4:     // utterance
	    		    for( i = 0; i < seqArray.length / 4; i ++ )
	    		    {
   			            minPeriod = Math.min( minPeriod, Math.floor(seqArray[i * 4 + 2] / 1000) );
    			        maxPeriod = Math.max( maxPeriod, Math.ceil(seqArray[i * 4 + 3] / 1000) );
	    		    }
	    		    break;
			    
			    case 5:     // SemRep
			    case 6:     // correlation
			        continue;
			    }
			}	
		}
	}
	tagWidth += padding * 2;
	
	// calculate canvas width
	canvasWidth = Math.max( screen.width, gridWidth * (maxPeriod - minPeriod + 1) + padding * 2 );


	//
	// draw block sequences
	//
	var yPos = 0;
	
	if( subjectLayout )
	{	// subject layout
	
		if( stimulusOrient )
		{	// ordered by stimulus
				
			for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
			{
				stimName = stimArray[stmIdx];
	
				// draw headline
				yPos = drawHeadline( jg, 0, yPos, stimName );
	
				for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
				{
					subjectName = dataArray[stmIdx][sbjIdx][0];
			
					// draw section divider
					yPos = drawSection( jg, 0, yPos, subjectName );
		
					// draw block sequences				
					for( seq = 1; seq < 7; seq ++ )
					{
						yPos = drawBlockSequence( jg, 0, yPos, seq, dataArray[stmIdx][sbjIdx][seq], '' );
						jg.paint();
					}
				}
			}
		
		} else
		{	// ordered by subject
		
			var subjNames = new Array();
			var nameIdx;
	
			// retrieve all subject names
			for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
			{
				for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
				{
					subjectName = dataArray[stmIdx][sbjIdx][0];

					// insert the name only if it's new
					for( nameIdx = 0; nameIdx < subjNames.length; nameIdx ++ )
						if( subjNames[nameIdx] == subjectName ) break;
						
					if( nameIdx >= subjNames.length )
						subjNames[nameIdx] = subjectName;			
				}
			}			
			for( nameIdx = 0; nameIdx < subjNames.length; nameIdx ++ )
			{
				// draw headline
				yPos = drawHeadline( jg, 0, yPos, subjNames[nameIdx] );
	
				for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
				{
					stimName = stimArray[stmIdx];
					
					var drawStim = false;
	
					for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
					{
						subjectName = dataArray[stmIdx][sbjIdx][0];
						if( subjectName == subjNames[nameIdx] )
							drawStim = true;
					}
					
					if( !drawStim ) continue;
		
					// draw section divider
					yPos = drawSection( jg, 0, yPos, stimName );
		
					for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
					{
						subjectName = dataArray[stmIdx][sbjIdx][0];
						if( subjectName != subjNames[nameIdx] ) continue;	
			
						// draw block sequences				
						for( seq = 1; seq < 7; seq ++ )
						{
							yPos = drawBlockSequence( jg, 0, yPos, seq, dataArray[stmIdx][sbjIdx][seq], '' );
							jg.paint();
						}
					}
				}
			}
		
		}		
	} else
	{	// component layout
	
		var seq;
        var seqName = new Array('', 'Eye-trace', 'Fixation Tag', 'Transcript Tag', 'Utterance', 'SemRep');
        
		if( stimulusOrient )
		{	// ordered by stimulus
            
			for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
			{
				stimName = stimArray[stmIdx];
				
				// draw headline
				yPos = drawHeadline( jg, tagWidth, yPos, stimName );
	
				var drawSeq = new Array(false, false, false, false, false, false);
				
				for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
				{
					for( seq = 1; seq < 6/*tag correlation not available*/; seq ++ )
					{
						if( dataArray[stmIdx][sbjIdx][seq].length > 0 )
							drawSeq[seq] = true;
					}
				}
	
				// draw components
				for( seq = 1; seq < 6/*tag correlation not available*/; seq ++ )
				{
					if( drawSeq[seq] )
					{
						// draw section divider
						yPos = drawSection( jg, tagWidth, yPos, seqName[seq] );
						
						// draw block sequences
						for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
						{
							subjectName = dataArray[stmIdx][sbjIdx][0];
							
							yPos = drawBlockSequence( jg, 0, yPos, seq, dataArray[stmIdx][sbjIdx][seq], subjectName );
							jg.paint();
						}
					}
				}
			}
			
		} else
		{	// ordered by component
		
			for( seq = 1; seq < 6/*tag correlation not available*/; seq ++ )
			{
				var drawSeq = false;
				var drawStim = new Array();
				
				for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
				{
					drawStim[stmIdx] = false;
					for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
					{
						if( dataArray[stmIdx][sbjIdx][seq].length > 0 )
						{
							drawSeq = true;
							drawStim[stmIdx] = true;
						}
					}
				}
				
				if( !drawSeq ) continue;
	
				// draw headline
				yPos = drawHeadline( jg, tagWidth, yPos, seqName[seq] );
				
				for( stmIdx = 0; stmIdx < stimArray.length; stmIdx ++ )
				{
					if( !drawStim[stmIdx] ) continue;
	
					stimName = stimArray[stmIdx];
				
					// draw section divider
					yPos = drawSection( jg, tagWidth, yPos, stimName );
				
					// draw block sequences
					for( sbjIdx = 0; sbjIdx < dataArray[stmIdx].length; sbjIdx ++ )
					{
						subjectName = dataArray[stmIdx][sbjIdx][0];
						
						yPos = drawBlockSequence( jg, 0, yPos, seq, dataArray[stmIdx][sbjIdx][seq], subjectName );
						jg.paint();
					}
				}
			}
			
		}
	}
}

function resetChart()
{
	// reset varibales
	stimulusOrient = document.params.orient != null ? document.params.orient.checked : true;
	subjectLayout = document.params.layout != null ? document.params.layout[0].checked : true;
	gridWidth = document.params.width != null ? document.params.width.value : 150;
	thumbWidth = document.params.thumb != null && document.params.thumb[0].checked ? 64 : 32;
	thumbHeight = imageHeight * thumbWidth / imageWidth ;
	tallView = document.params.view != null ? document.params.view[0].checked : true;

	drawChart();
}

// initially draw chart
resetChart();

</script>

</body>
</html>

